/**
 * Bundle of @devexpress/dx-react-grid
 * Generated: 2018-12-25
 * Version: 1.10.0
 * License: https://js.devexpress.com/Licensing
 */

import { createElement, PureComponent, Fragment, createRef } from 'react';
import { array, func, node, object, bool, number, arrayOf, string, shape, any, oneOfType, symbol, oneOf } from 'prop-types';
import { Plugin, Getter, Template, TemplatePlaceholder, PluginHost, TemplateConnector, createStateHelper, Action, DragDropProvider, withComponents, DropTarget, DragSource, RefHolder, Sizer, RefType, connectProps } from '@devexpress/dx-react-core';
import { rowIdGetter, cellValueGetter, columnChooserItems, changeColumnFilter, getColumnExtensionValueGetter, filterExpression, defaultFilterPredicate, filteredCollapsedRowsGetter, unwrappedFilteredRows, filteredRows, getColumnExtension, startEditRows, stopEditRows, changeRow, cancelChanges, changedRowsByIds, addRow, changeAddedRow, cancelAddedRows, addedRowsByIds, deleteRows, cancelDeletedRows, createRowChangeGetter, setCurrentPage, setPageSize, rowsWithPageHeaders, rowCount, paginatedRows, currentPage, toggleExpandedGroups, draftColumnGrouping, cancelColumnGroupingDraft, adjustSortIndex, changeColumnGrouping, groupRowChecker, groupRowLevelKeyGetter, groupCollapsedRowsGetter, expandedGroupRows, groupedRows, customGroupingRowIdGetter, customGroupedRows, toggleSelection, rowsWithAvailableToSelect, allSelected, someSelected, unwrapSelectedRows, getPersistentSortedColumns, calculateKeepOther, changeColumnSorting, sortedRows, draftOrder, TABLE_DATA_TYPE, getTableTargetColumnIndex, changeColumnOrder, TABLE_REORDERING_TYPE, tableHeaderRowsWithReordering, orderedColumns, tableColumnsWithDataRows, tableCellColSpanGetter, isHeaderStubTableCell, isDataTableCell, isNoDataTableRow, isNoDataTableCell, isDataTableRow, TABLE_NODATA_TYPE, tableRowsWithDataRows, isSelectAllTableCell, isSelectTableCell, TABLE_SELECT_TYPE, tableColumnsWithSelection, toggleDetailRowExpanded, isDetailToggleTableCell, isDetailRowExpanded, isDetailTableRow, isDetailTableCell, TABLE_DETAIL_TYPE, tableDetailCellColSpanGetter, tableColumnsWithDetail, tableRowsWithExpandedDetail, isGroupTableRow, isGroupTableCell, isGroupIndentTableCell, TABLE_GROUP_TYPE, tableRowsWithGrouping, tableGroupCellColSpanGetter, tableColumnsWithGrouping, isHeadingTableCell, getColumnSortingDirection, isHeadingTableRow, TABLE_HEADING_TYPE, tableRowsWithHeading, isBandedOrHeaderRow, getBandComponent, BAND_DUPLICATE_RENDER, BAND_EMPTY_CELL, BAND_GROUP_CELL, BAND_HEADER_CELL, isBandedTableRow, TABLE_BAND_TYPE, tableRowsWithBands, tableHeaderColumnChainsWithBands, isFilterTableCell, getColumnFilterConfig, getColumnFilterOperations, getSelectedFilterOperation, isFilterTableRow, TABLE_FILTER_TYPE, tableHeaderRowsWithFilter, isFilterValueEmpty, isEditTableCell, isAddedTableRow, getRowChange, isEditTableRow, TABLE_ADDED_TYPE, TABLE_EDIT_TYPE, tableRowsWithEditing, isHeadingEditCommandsTableCell, isEditCommandsTableCell, TABLE_EDIT_COMMAND_TYPE, tableColumnsWithEditing, tableColumnsWithWidths, tableColumnsWithDraftWidths, changeTableColumnWidth, draftTableColumnWidth, cancelTableColumnWidthDraft, pageCount, getGroupCellTargetIndex, groupingPanelItems, getAvailableFilterOperationsGetter, toggleColumn, tableDataColumnsExist, visibleTableColumns, toggleRowExpanded, expandedTreeRows, customTreeRowIdGetter, customTreeRowLevelKeyGetter, isTreeRowLeafGetter, getTreeRowLevelGetter, collapsedTreeRowsGetter, unwrappedCustomTreeRows, customTreeRowsWithMeta, isTreeTableCell, changeSearchValue, searchFilterExpression, calculateFixedColumnProps, isFixedTableRow, tableHeaderRowsWithFixed, tableHeaderColumnChainsWithFixed, tableColumnsWithFixed, defaultSummaryCalculator, totalSummaryValues, groupSummaryValues, treeSummaryValues, isTotalSummaryTableCell, getColumnSummaries, isGroupSummaryTableCell, isTreeSummaryTableCell, isTotalSummaryTableRow, isGroupSummaryTableRow, isTreeSummaryTableRow, TABLE_TREE_SUMMARY_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_TOTAL_SUMMARY_TYPE, tableRowsWithSummaries, tableRowsWithTotalSummaries, getAnimations, TABLE_FLEX_TYPE, filterActiveAnimations, evalAnimations, TABLE_STUB_TYPE, getCollapsedGrid } from '@devexpress/dx-grid-core';
import { getMessagesFormatter, memoize, isEdgeBrowser } from '@devexpress/dx-core';
import { findDOMNode } from 'react-dom';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var GridCore =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(GridCore, _React$PureComponent);

  function GridCore() {
    _classCallCheck(this, GridCore);

    return _possibleConstructorReturn(this, _getPrototypeOf(GridCore).apply(this, arguments));
  }

  _createClass(GridCore, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          rows = _this$props.rows,
          columns = _this$props.columns,
          getRowId = _this$props.getRowId,
          getCellValue = _this$props.getCellValue,
          Root = _this$props.rootComponent;
      return createElement(Plugin, null, createElement(Getter, {
        name: "rows",
        value: rows
      }), createElement(Getter, {
        name: "getRowId",
        value: rowIdGetter(getRowId, rows)
      }), createElement(Getter, {
        name: "columns",
        value: columns
      }), createElement(Getter, {
        name: "getCellValue",
        value: cellValueGetter(getCellValue, columns)
      }), createElement(Template, {
        name: "root"
      }, createElement(Root, null, createElement(TemplatePlaceholder, {
        name: "header"
      }), createElement(TemplatePlaceholder, {
        name: "body"
      }), createElement(TemplatePlaceholder, {
        name: "footer"
      }))));
    }
  }]);

  return GridCore;
}(PureComponent);
process.env.NODE_ENV !== "production" ? GridCore.propTypes = {
  rows: array.isRequired,
  getRowId: func,
  getCellValue: func,
  columns: array.isRequired,
  rootComponent: func.isRequired
} : void 0;
GridCore.defaultProps = {
  getRowId: undefined,
  getCellValue: undefined
};

var Grid = function Grid(_ref) {
  var rows = _ref.rows,
      columns = _ref.columns,
      getRowId = _ref.getRowId,
      getCellValue = _ref.getCellValue,
      rootComponent = _ref.rootComponent,
      children = _ref.children;
  return createElement(PluginHost, null, createElement(GridCore, {
    rows: rows,
    columns: columns,
    getRowId: getRowId,
    getCellValue: getCellValue,
    rootComponent: rootComponent
  }), children);
};
process.env.NODE_ENV !== "production" ? Grid.propTypes = {
  rows: array.isRequired,
  getRowId: func,
  getCellValue: func,
  columns: array.isRequired,
  rootComponent: func.isRequired,
  children: node
} : void 0;
Grid.defaultProps = {
  getRowId: undefined,
  getCellValue: undefined,
  children: undefined
};

var pluginDependencies = [{
  name: 'TableColumnVisibility'
}, {
  name: 'Toolbar'
}];
var ColumnChooser =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(ColumnChooser, _React$PureComponent);

  function ColumnChooser(props) {
    var _this;

    _classCallCheck(this, ColumnChooser);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ColumnChooser).call(this, props));
    _this.state = {
      visible: false
    };
    _this.handleToggle = _this.handleToggle.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleHide = _this.handleHide.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.setButtonRef = _this.setButtonRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(ColumnChooser, [{
    key: "setButtonRef",
    value: function setButtonRef(button) {
      this.button = button;
    }
  }, {
    key: "handleToggle",
    value: function handleToggle() {
      var visible = this.state.visible;
      this.setState({
        visible: !visible
      });
    }
  }, {
    key: "handleHide",
    value: function handleHide() {
      this.setState({
        visible: false
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          Overlay = _this$props.overlayComponent,
          Container = _this$props.containerComponent,
          Item = _this$props.itemComponent,
          ToggleButton = _this$props.toggleButtonComponent,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(messages);
      var visible = this.state.visible;
      return createElement(Plugin, {
        name: "ColumnChooser",
        dependencies: pluginDependencies
      }, createElement(Template, {
        name: "toolbarContent"
      }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_ref, _ref2) {
        var columns = _ref.columns,
            hiddenColumnNames = _ref.hiddenColumnNames,
            isColumnTogglingEnabled = _ref.isColumnTogglingEnabled;
        var toggleColumnVisibility = _ref2.toggleColumnVisibility;
        return createElement(Fragment, null, createElement(ToggleButton, {
          buttonRef: _this2.setButtonRef,
          onToggle: _this2.handleToggle,
          getMessage: getMessage,
          active: visible
        }), createElement(Overlay, {
          visible: visible,
          target: _this2.button,
          onHide: _this2.handleHide
        }, createElement(Container, null, columnChooserItems(columns, hiddenColumnNames).map(function (item) {
          var columnName = item.column.name;
          var togglingEnabled = isColumnTogglingEnabled(columnName);
          return createElement(Item, {
            key: columnName,
            item: item,
            disabled: !togglingEnabled,
            onToggle: function onToggle() {
              return toggleColumnVisibility(columnName);
            }
          });
        }))));
      })));
    }
  }]);

  return ColumnChooser;
}(PureComponent);
process.env.NODE_ENV !== "production" ? ColumnChooser.propTypes = {
  overlayComponent: func.isRequired,
  containerComponent: func.isRequired,
  itemComponent: func.isRequired,
  toggleButtonComponent: func.isRequired,
  messages: object
} : void 0;
ColumnChooser.defaultProps = {
  messages: {}
};
ColumnChooser.components = {
  overlayComponent: 'Overlay',
  containerComponent: 'Container',
  itemComponent: 'Item',
  toggleButtonComponent: 'ToggleButton'
};

var columnExtensionValueGetter = function columnExtensionValueGetter(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, 'filteringEnabled', defaultValue);
};

var filterExpressionComputed = function filterExpressionComputed(_ref) {
  var filters = _ref.filters,
      filterExpressionValue = _ref.filterExpression;
  return filterExpression(filters, filterExpressionValue);
};

var FilteringState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(FilteringState, _React$PureComponent);

  function FilteringState(props) {
    var _this;

    _classCallCheck(this, FilteringState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FilteringState).call(this, props));
    _this.state = {
      filters: props.filters || props.defaultFilters
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      filters: function filters() {
        var onFiltersChange = _this.props.onFiltersChange;
        return onFiltersChange;
      }
    });
    _this.changeColumnFilter = stateHelper.applyFieldReducer.bind(stateHelper, 'filters', changeColumnFilter);
    return _this;
  }

  _createClass(FilteringState, [{
    key: "render",
    value: function render() {
      var filters = this.state.filters;
      var _this$props = this.props,
          columnExtensions = _this$props.columnExtensions,
          columnFilteringEnabled = _this$props.columnFilteringEnabled;
      return createElement(Plugin, {
        name: "FilteringState"
      }, createElement(Getter, {
        name: "filters",
        value: filters
      }), createElement(Getter, {
        name: "filterExpression",
        computed: filterExpressionComputed
      }), createElement(Getter, {
        name: "isColumnFilteringEnabled",
        value: columnExtensionValueGetter(columnExtensions, columnFilteringEnabled)
      }), createElement(Action, {
        name: "changeColumnFilter",
        action: this.changeColumnFilter
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$filters = nextProps.filters,
          filters = _nextProps$filters === void 0 ? prevState.filters : _nextProps$filters;
      return {
        filters: filters
      };
    }
  }]);

  return FilteringState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? FilteringState.propTypes = {
  filters: array,
  defaultFilters: array,
  onFiltersChange: func,
  columnExtensions: array,
  columnFilteringEnabled: bool
} : void 0;
FilteringState.defaultProps = {
  filters: undefined,
  defaultFilters: [],
  onFiltersChange: undefined,
  columnExtensions: undefined,
  columnFilteringEnabled: true
};

var pluginDependencies$1 = [{
  name: 'FilteringState',
  optional: true
}, {
  name: 'SearchState',
  optional: true
}];

var getCollapsedRowsComputed = function getCollapsedRowsComputed(_ref) {
  var rows = _ref.rows;
  return filteredCollapsedRowsGetter(rows);
};

var unwrappedRowsComputed = function unwrappedRowsComputed(_ref2) {
  var rows = _ref2.rows;
  return unwrappedFilteredRows(rows);
};

var IntegratedFiltering =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(IntegratedFiltering, _React$PureComponent);

  function IntegratedFiltering() {
    _classCallCheck(this, IntegratedFiltering);

    return _possibleConstructorReturn(this, _getPrototypeOf(IntegratedFiltering).apply(this, arguments));
  }

  _createClass(IntegratedFiltering, [{
    key: "render",
    value: function render() {
      var columnExtensions = this.props.columnExtensions;

      var getColumnPredicate = function getColumnPredicate(columnName) {
        return getColumnExtension(columnExtensions, columnName).predicate;
      };

      var rowsComputed = function rowsComputed(_ref3) {
        var rows = _ref3.rows,
            filterExpression$$1 = _ref3.filterExpression,
            getCellValue = _ref3.getCellValue,
            getRowLevelKey = _ref3.getRowLevelKey,
            getCollapsedRows = _ref3.getCollapsedRows;
        return filteredRows(rows, filterExpression$$1, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows);
      };

      return createElement(Plugin, {
        name: "IntegratedFiltering",
        dependencies: pluginDependencies$1
      }, createElement(Getter, {
        name: "rows",
        computed: rowsComputed
      }), createElement(Getter, {
        name: "getCollapsedRows",
        computed: getCollapsedRowsComputed
      }), createElement(Getter, {
        name: "rows",
        computed: unwrappedRowsComputed
      }));
    }
  }]);

  return IntegratedFiltering;
}(PureComponent);
IntegratedFiltering.defaultPredicate = defaultFilterPredicate;
process.env.NODE_ENV !== "production" ? IntegratedFiltering.propTypes = {
  columnExtensions: array
} : void 0;
IntegratedFiltering.defaultProps = {
  columnExtensions: undefined
};

var columnExtensionValueGetter$1 = function columnExtensionValueGetter(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, 'editingEnabled', defaultValue);
};

var EditingState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(EditingState, _React$PureComponent);

  function EditingState(props) {
    var _this;

    _classCallCheck(this, EditingState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditingState).call(this, props));
    var rowChanges = props.rowChanges || props.defaultRowChanges;
    var addedRows = props.addedRows || props.defaultAddedRows;

    var getRowChanges = function getRowChanges() {
      var stateRowChanges = _this.state.rowChanges;
      return stateRowChanges;
    };

    var getAddedRows = function getAddedRows() {
      var stateAddedRows = _this.state.addedRows;
      return stateAddedRows;
    };

    _this.state = {
      editingRowIds: props.editingRowIds || props.defaultEditingRowIds,
      addedRows: addedRows,
      rowChanges: rowChanges,
      deletedRowIds: props.deletedRowIds || props.defaultDeletedRowIds
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      editingRowIds: function editingRowIds() {
        var onEditingRowIdsChange = _this.props.onEditingRowIdsChange;
        return onEditingRowIdsChange;
      },
      addedRows: function addedRows() {
        var onAddedRowsChange = _this.props.onAddedRowsChange;
        return onAddedRowsChange;
      },
      rowChanges: function rowChanges() {
        var onRowChangesChange = _this.props.onRowChangesChange;
        return onRowChangesChange;
      },
      deletedRowIds: function deletedRowIds() {
        var onDeletedRowIdsChange = _this.props.onDeletedRowIdsChange;
        return onDeletedRowIdsChange;
      }
    });
    _this.startEditRows = stateHelper.applyFieldReducer.bind(stateHelper, 'editingRowIds', startEditRows);
    _this.stopEditRows = stateHelper.applyFieldReducer.bind(stateHelper, 'editingRowIds', stopEditRows);
    _this.changeRow = stateHelper.applyFieldReducer.bind(stateHelper, 'rowChanges', changeRow);
    _this.cancelChangedRows = stateHelper.applyFieldReducer.bind(stateHelper, 'rowChanges', cancelChanges);

    _this.commitChangedRows = function (_ref) {
      var rowIds = _ref.rowIds;
      var onCommitChanges = _this.props.onCommitChanges;
      onCommitChanges({
        changed: changedRowsByIds(getRowChanges(), rowIds)
      });

      _this.cancelChangedRows({
        rowIds: rowIds
      });
    };

    _this.addRow = stateHelper.applyFieldReducer.bind(stateHelper, 'addedRows', addRow);
    _this.changeAddedRow = stateHelper.applyFieldReducer.bind(stateHelper, 'addedRows', changeAddedRow);
    _this.cancelAddedRows = stateHelper.applyFieldReducer.bind(stateHelper, 'addedRows', cancelAddedRows);

    _this.commitAddedRows = function (_ref2) {
      var rowIds = _ref2.rowIds;
      var onCommitChanges = _this.props.onCommitChanges;
      onCommitChanges({
        added: addedRowsByIds(getAddedRows(), rowIds)
      });

      _this.cancelAddedRows({
        rowIds: rowIds
      });
    };

    _this.deleteRows = stateHelper.applyFieldReducer.bind(stateHelper, 'deletedRowIds', deleteRows);
    _this.cancelDeletedRows = stateHelper.applyFieldReducer.bind(stateHelper, 'deletedRowIds', cancelDeletedRows);

    _this.commitDeletedRows = function (_ref3) {
      var rowIds = _ref3.rowIds;
      var onCommitChanges = _this.props.onCommitChanges;
      onCommitChanges({
        deleted: rowIds
      });

      _this.cancelDeletedRows({
        rowIds: rowIds
      });
    };

    return _this;
  }

  _createClass(EditingState, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          createRowChange = _this$props.createRowChange,
          columnExtensions = _this$props.columnExtensions,
          columnEditingEnabled = _this$props.columnEditingEnabled;
      var _this$state = this.state,
          editingRowIds = _this$state.editingRowIds,
          rowChanges = _this$state.rowChanges,
          addedRows = _this$state.addedRows,
          deletedRowIds = _this$state.deletedRowIds;
      return createElement(Plugin, {
        name: "EditingState"
      }, createElement(Getter, {
        name: "createRowChange",
        value: createRowChangeGetter(createRowChange, columnExtensions)
      }), createElement(Getter, {
        name: "editingRowIds",
        value: editingRowIds
      }), createElement(Action, {
        name: "startEditRows",
        action: this.startEditRows
      }), createElement(Action, {
        name: "stopEditRows",
        action: this.stopEditRows
      }), createElement(Getter, {
        name: "rowChanges",
        value: rowChanges
      }), createElement(Action, {
        name: "changeRow",
        action: this.changeRow
      }), createElement(Action, {
        name: "cancelChangedRows",
        action: this.cancelChangedRows
      }), createElement(Action, {
        name: "commitChangedRows",
        action: this.commitChangedRows
      }), createElement(Getter, {
        name: "addedRows",
        value: addedRows
      }), createElement(Action, {
        name: "addRow",
        action: this.addRow
      }), createElement(Action, {
        name: "changeAddedRow",
        action: this.changeAddedRow
      }), createElement(Action, {
        name: "cancelAddedRows",
        action: this.cancelAddedRows
      }), createElement(Action, {
        name: "commitAddedRows",
        action: this.commitAddedRows
      }), createElement(Getter, {
        name: "deletedRowIds",
        value: deletedRowIds
      }), createElement(Action, {
        name: "deleteRows",
        action: this.deleteRows
      }), createElement(Action, {
        name: "cancelDeletedRows",
        action: this.cancelDeletedRows
      }), createElement(Action, {
        name: "commitDeletedRows",
        action: this.commitDeletedRows
      }), createElement(Getter, {
        name: "isColumnEditingEnabled",
        value: columnExtensionValueGetter$1(columnExtensions, columnEditingEnabled)
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$editingRow = nextProps.editingRowIds,
          editingRowIds = _nextProps$editingRow === void 0 ? prevState.editingRowIds : _nextProps$editingRow,
          _nextProps$rowChanges = nextProps.rowChanges,
          rowChanges = _nextProps$rowChanges === void 0 ? prevState.rowChanges : _nextProps$rowChanges,
          _nextProps$addedRows = nextProps.addedRows,
          addedRows = _nextProps$addedRows === void 0 ? prevState.addedRows : _nextProps$addedRows,
          _nextProps$deletedRow = nextProps.deletedRowIds,
          deletedRowIds = _nextProps$deletedRow === void 0 ? prevState.deletedRowIds : _nextProps$deletedRow;
      return {
        editingRowIds: editingRowIds,
        rowChanges: rowChanges,
        addedRows: addedRows,
        deletedRowIds: deletedRowIds
      };
    }
  }]);

  return EditingState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? EditingState.propTypes = {
  createRowChange: func,
  columnEditingEnabled: bool,
  columnExtensions: array,
  editingRowIds: array,
  defaultEditingRowIds: array,
  onEditingRowIdsChange: func,
  addedRows: array,
  defaultAddedRows: array,
  onAddedRowsChange: func,
  rowChanges: object,
  defaultRowChanges: object,
  onRowChangesChange: func,
  deletedRowIds: array,
  defaultDeletedRowIds: array,
  onDeletedRowIdsChange: func,
  onCommitChanges: func.isRequired
} : void 0;
EditingState.defaultProps = {
  createRowChange: undefined,
  columnEditingEnabled: true,
  columnExtensions: undefined,
  editingRowIds: undefined,
  defaultEditingRowIds: [],
  onEditingRowIdsChange: undefined,
  rowChanges: undefined,
  defaultRowChanges: {},
  onRowChangesChange: undefined,
  addedRows: undefined,
  defaultAddedRows: [],
  onAddedRowsChange: undefined,
  deletedRowIds: undefined,
  defaultDeletedRowIds: [],
  onDeletedRowIdsChange: undefined
};

var PagingState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(PagingState, _React$PureComponent);

  function PagingState(props) {
    var _this;

    _classCallCheck(this, PagingState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PagingState).call(this, props));
    _this.state = {
      currentPage: props.currentPage || props.defaultCurrentPage,
      pageSize: props.pageSize !== undefined ? props.pageSize : props.defaultPageSize
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      currentPage: function currentPage$$1() {
        var onCurrentPageChange = _this.props.onCurrentPageChange;
        return onCurrentPageChange;
      },
      pageSize: function pageSize() {
        var onPageSizeChange = _this.props.onPageSizeChange;
        return onPageSizeChange;
      }
    });
    _this.setCurrentPage = stateHelper.applyFieldReducer.bind(stateHelper, 'currentPage', setCurrentPage);
    _this.setPageSize = stateHelper.applyFieldReducer.bind(stateHelper, 'pageSize', setPageSize);
    return _this;
  }

  _createClass(PagingState, [{
    key: "render",
    value: function render() {
      var _this$state = this.state,
          pageSize = _this$state.pageSize,
          currentPage$$1 = _this$state.currentPage;
      return createElement(Plugin, {
        name: "PagingState"
      }, createElement(Getter, {
        name: "currentPage",
        value: currentPage$$1
      }), createElement(Getter, {
        name: "pageSize",
        value: pageSize
      }), createElement(Action, {
        name: "setCurrentPage",
        action: this.setCurrentPage
      }), createElement(Action, {
        name: "setPageSize",
        action: this.setPageSize
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$currentPag = nextProps.currentPage,
          currentPage$$1 = _nextProps$currentPag === void 0 ? prevState.currentPage : _nextProps$currentPag,
          _nextProps$pageSize = nextProps.pageSize,
          pageSize = _nextProps$pageSize === void 0 ? prevState.pageSize : _nextProps$pageSize;
      return {
        currentPage: currentPage$$1,
        pageSize: pageSize
      };
    }
  }]);

  return PagingState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? PagingState.propTypes = {
  pageSize: number,
  defaultPageSize: number,
  onPageSizeChange: func,
  currentPage: number,
  defaultCurrentPage: number,
  onCurrentPageChange: func
} : void 0;
PagingState.defaultProps = {
  pageSize: undefined,
  defaultPageSize: 10,
  onPageSizeChange: undefined,
  currentPage: undefined,
  defaultCurrentPage: 0,
  onCurrentPageChange: undefined
};

var pluginDependencies$2 = [{
  name: 'PagingState'
}];

var rowsWithHeadersComputed = function rowsWithHeadersComputed(_ref) {
  var rows = _ref.rows,
      pageSize = _ref.pageSize,
      getRowLevelKey = _ref.getRowLevelKey;
  return rowsWithPageHeaders(rows, pageSize, getRowLevelKey);
};

var totalCountComputed = function totalCountComputed(_ref2) {
  var rows = _ref2.rows;
  return rowCount(rows);
};

var paginatedRowsComputed = function paginatedRowsComputed(_ref3) {
  var rows = _ref3.rows,
      pageSize = _ref3.pageSize,
      page = _ref3.currentPage;
  return paginatedRows(rows, pageSize, page);
};

var currentPageComputed = function currentPageComputed(_ref4, _ref5) {
  var page = _ref4.currentPage,
      totalCount = _ref4.totalCount,
      pageSize = _ref4.pageSize;
  var setCurrentPage$$1 = _ref5.setCurrentPage;
  return currentPage(page, totalCount, pageSize, setCurrentPage$$1);
}; // eslint-disable-next-line react/prefer-stateless-function


var IntegratedPaging =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(IntegratedPaging, _React$PureComponent);

  function IntegratedPaging() {
    _classCallCheck(this, IntegratedPaging);

    return _possibleConstructorReturn(this, _getPrototypeOf(IntegratedPaging).apply(this, arguments));
  }

  _createClass(IntegratedPaging, [{
    key: "render",
    value: function render() {
      return createElement(Plugin, {
        name: "IntegratedPaging",
        dependencies: pluginDependencies$2
      }, createElement(Getter, {
        name: "rows",
        computed: rowsWithHeadersComputed
      }), createElement(Getter, {
        name: "totalCount",
        computed: totalCountComputed
      }), createElement(Getter, {
        name: "currentPage",
        computed: currentPageComputed
      }), createElement(Getter, {
        name: "rows",
        computed: paginatedRowsComputed
      }));
    }
  }]);

  return IntegratedPaging;
}(PureComponent);

var pluginDependencies$3 = [{
  name: 'PagingState'
}];
var CustomPaging =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(CustomPaging, _React$PureComponent);

  function CustomPaging() {
    _classCallCheck(this, CustomPaging);

    return _possibleConstructorReturn(this, _getPrototypeOf(CustomPaging).apply(this, arguments));
  }

  _createClass(CustomPaging, [{
    key: "render",
    value: function render() {
      var totalCount = this.props.totalCount;
      return createElement(Plugin, {
        name: "CustomPaging",
        dependencies: pluginDependencies$3
      }, createElement(Getter, {
        name: "totalCount",
        value: totalCount
      }));
    }
  }]);

  return CustomPaging;
}(PureComponent);
process.env.NODE_ENV !== "production" ? CustomPaging.propTypes = {
  totalCount: number
} : void 0;
CustomPaging.defaultProps = {
  totalCount: 0
};

var dependencies = [{
  name: 'SortingState',
  optional: true
}];

var columnExtensionValueGetter$2 = function columnExtensionValueGetter(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, 'groupingEnabled', defaultValue);
};

var GroupingState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(GroupingState, _React$PureComponent);

  function GroupingState(props) {
    var _this;

    _classCallCheck(this, GroupingState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GroupingState).call(this, props));
    _this.state = {
      grouping: props.grouping || props.defaultGrouping,
      draftGrouping: null,
      expandedGroups: props.expandedGroups || props.defaultExpandedGroups
    };
    _this.stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      grouping: function grouping() {
        var onGroupingChange = _this.props.onGroupingChange;
        return onGroupingChange;
      },
      expandedGroups: function expandedGroups() {
        var onExpandedGroupsChange = _this.props.onExpandedGroupsChange;
        return onExpandedGroupsChange;
      }
    });
    _this.changeColumnGrouping = _this.changeColumnGrouping.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggleGroupExpanded = _this.stateHelper.applyReducer.bind(_this.stateHelper, toggleExpandedGroups);
    _this.draftColumnGrouping = _this.stateHelper.applyReducer.bind(_this.stateHelper, draftColumnGrouping);
    _this.cancelColumnGroupingDraft = _this.stateHelper.applyReducer.bind(_this.stateHelper, cancelColumnGroupingDraft);
    _this.changeColumnSorting = _this.changeColumnSorting.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(GroupingState, [{
    key: "changeColumnSorting",
    value: function changeColumnSorting$$1(_ref, _ref2, _ref3) {
      var columnName = _ref.columnName,
          keepOther = _ref.keepOther,
          restParams = _objectWithoutProperties(_ref, ["columnName", "keepOther"]);

      var sorting = _ref2.sorting;
      var _changeColumnSorting = _ref3.changeColumnSorting;
      var grouping = this.state.grouping;
      var groupingIndex = grouping.findIndex(function (columnGrouping) {
        return columnGrouping.columnName === columnName;
      });

      if (groupingIndex === -1) {
        _changeColumnSorting(_objectSpread({
          columnName: columnName,
          keepOther: keepOther || grouping.map(function (columnGrouping) {
            return columnGrouping.columnName;
          })
        }, restParams));

        return false;
      }

      var sortIndex = adjustSortIndex(groupingIndex, grouping, sorting);

      _changeColumnSorting(_objectSpread({
        columnName: columnName,
        keepOther: true,
        sortIndex: sortIndex
      }, restParams));

      return false;
    }
  }, {
    key: "changeColumnGrouping",
    value: function changeColumnGrouping$$1(_ref4, getters, actions) {
      var columnName = _ref4.columnName,
          groupIndex = _ref4.groupIndex;
      this.stateHelper.applyReducer(changeColumnGrouping, {
        columnName: columnName,
        groupIndex: groupIndex
      }, function (nextState, state) {
        var grouping = nextState.grouping;
        var prevGrouping = state.grouping;
        var sorting = getters.sorting;
        var changeColumnSorting$$1 = actions.changeColumnSorting;
        if (!sorting) return;
        var columnSortingIndex = sorting.findIndex(function (columnSorting) {
          return columnSorting.columnName === columnName;
        });
        var prevGroupingIndex = prevGrouping.findIndex(function (columnGrouping) {
          return columnGrouping.columnName === columnName;
        });
        var groupingIndex = grouping.findIndex(function (columnGrouping) {
          return columnGrouping.columnName === columnName;
        });
        if (columnSortingIndex === -1 || prevGroupingIndex === prevGrouping.length - 1 && groupingIndex === -1) return;
        var sortIndex = adjustSortIndex(groupingIndex === -1 ? grouping.length : groupingIndex, grouping, sorting);
        if (columnSortingIndex === sortIndex) return;
        changeColumnSorting$$1(_objectSpread({
          keepOther: true,
          sortIndex: sortIndex
        }, sorting[columnSortingIndex]));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
          grouping = _this$state.grouping,
          draftGrouping = _this$state.draftGrouping,
          expandedGroups = _this$state.expandedGroups;
      var _this$props = this.props,
          columnExtensions = _this$props.columnExtensions,
          columnGroupingEnabled = _this$props.columnGroupingEnabled;
      return createElement(Plugin, {
        name: "GroupingState",
        dependencies: dependencies
      }, createElement(Getter, {
        name: "grouping",
        value: grouping
      }), createElement(Getter, {
        name: "draftGrouping",
        value: draftGrouping || grouping
      }), createElement(Getter, {
        name: "isColumnGroupingEnabled",
        value: columnExtensionValueGetter$2(columnExtensions, columnGroupingEnabled)
      }), createElement(Action, {
        name: "changeColumnGrouping",
        action: this.changeColumnGrouping
      }), createElement(Action, {
        name: "draftColumnGrouping",
        action: this.draftColumnGrouping
      }), createElement(Action, {
        name: "cancelColumnGroupingDraft",
        action: this.cancelColumnGroupingDraft
      }), createElement(Getter, {
        name: "expandedGroups",
        value: expandedGroups
      }), createElement(Action, {
        name: "toggleGroupExpanded",
        action: this.toggleGroupExpanded
      }), createElement(Action, {
        name: "changeColumnSorting",
        action: this.changeColumnSorting
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$grouping = nextProps.grouping,
          grouping = _nextProps$grouping === void 0 ? prevState.grouping : _nextProps$grouping,
          _nextProps$expandedGr = nextProps.expandedGroups,
          expandedGroups = _nextProps$expandedGr === void 0 ? prevState.expandedGroups : _nextProps$expandedGr;
      return {
        grouping: grouping,
        expandedGroups: expandedGroups
      };
    }
  }]);

  return GroupingState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? GroupingState.propTypes = {
  grouping: array,
  defaultGrouping: array,
  onGroupingChange: func,
  expandedGroups: array,
  defaultExpandedGroups: array,
  onExpandedGroupsChange: func,
  columnExtensions: array,
  columnGroupingEnabled: bool
} : void 0;
GroupingState.defaultProps = {
  grouping: undefined,
  defaultGrouping: [],
  onGroupingChange: undefined,
  expandedGroups: undefined,
  defaultExpandedGroups: [],
  onExpandedGroupsChange: undefined,
  columnExtensions: undefined,
  columnGroupingEnabled: true
};

var pluginDependencies$4 = [{
  name: 'GroupingState'
}];

var getCollapsedRowsComputed$1 = function getCollapsedRowsComputed(_ref) {
  var getCollapsedRows = _ref.getCollapsedRows;
  return groupCollapsedRowsGetter(getCollapsedRows);
};

var expandedGroupedRowsComputed = function expandedGroupedRowsComputed(_ref2) {
  var rows = _ref2.rows,
      grouping = _ref2.grouping,
      expandedGroups = _ref2.expandedGroups;
  return expandedGroupRows(rows, grouping, expandedGroups);
};

var IntegratedGrouping =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(IntegratedGrouping, _React$PureComponent);

  function IntegratedGrouping() {
    _classCallCheck(this, IntegratedGrouping);

    return _possibleConstructorReturn(this, _getPrototypeOf(IntegratedGrouping).apply(this, arguments));
  }

  _createClass(IntegratedGrouping, [{
    key: "render",
    value: function render() {
      var columnExtensions = this.props.columnExtensions;

      var getColumnCriteria = function getColumnCriteria(columnName) {
        return getColumnExtension(columnExtensions, columnName).criteria;
      };

      var groupedRowsComputed = function groupedRowsComputed(_ref3) {
        var rows = _ref3.rows,
            grouping = _ref3.grouping,
            getCellValue = _ref3.getCellValue;
        return groupedRows(rows, grouping, getCellValue, getColumnCriteria);
      };

      return createElement(Plugin, {
        name: "IntegratedGrouping",
        dependencies: pluginDependencies$4
      }, createElement(Getter, {
        name: "isGroupRow",
        value: groupRowChecker
      }), createElement(Getter, {
        name: "getRowLevelKey",
        value: groupRowLevelKeyGetter
      }), createElement(Getter, {
        name: "getCollapsedRows",
        computed: getCollapsedRowsComputed$1
      }), createElement(Getter, {
        name: "rows",
        computed: groupedRowsComputed
      }), createElement(Getter, {
        name: "rows",
        computed: expandedGroupedRowsComputed
      }));
    }
  }]);

  return IntegratedGrouping;
}(PureComponent);
process.env.NODE_ENV !== "production" ? IntegratedGrouping.propTypes = {
  columnExtensions: array
} : void 0;
IntegratedGrouping.defaultProps = {
  columnExtensions: undefined
};

var pluginDependencies$5 = [{
  name: 'GroupingState'
}];

var getCollapsedRowsComputed$2 = function getCollapsedRowsComputed(_ref) {
  var getCollapsedRows = _ref.getCollapsedRows;
  return groupCollapsedRowsGetter(getCollapsedRows);
};

var expandedGroupedRowsComputed$1 = function expandedGroupedRowsComputed(_ref2) {
  var rows = _ref2.rows,
      grouping = _ref2.grouping,
      expandedGroups = _ref2.expandedGroups;
  return expandedGroupRows(rows, grouping, expandedGroups);
};

var getRowIdComputed = function getRowIdComputed(_ref3) {
  var getRowId = _ref3.getRowId,
      rows = _ref3.rows;
  return customGroupingRowIdGetter(getRowId, rows);
};

var CustomGrouping =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(CustomGrouping, _React$PureComponent);

  function CustomGrouping() {
    _classCallCheck(this, CustomGrouping);

    return _possibleConstructorReturn(this, _getPrototypeOf(CustomGrouping).apply(this, arguments));
  }

  _createClass(CustomGrouping, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          getChildGroups = _this$props.getChildGroups,
          appliedGrouping = _this$props.grouping,
          appliedExpandedGroups = _this$props.expandedGroups;

      var groupedRowsComputed = function groupedRowsComputed(_ref4) {
        var rows = _ref4.rows,
            grouping = _ref4.grouping;
        return customGroupedRows(rows, grouping, getChildGroups);
      };

      return createElement(Plugin, {
        name: "CustomGrouping",
        dependencies: pluginDependencies$5
      }, appliedGrouping && createElement(Getter, {
        name: "grouping",
        value: appliedGrouping
      }), appliedExpandedGroups && createElement(Getter, {
        name: "expandedGroups",
        value: appliedExpandedGroups
      }), createElement(Getter, {
        name: "isGroupRow",
        value: groupRowChecker
      }), createElement(Getter, {
        name: "getRowLevelKey",
        value: groupRowLevelKeyGetter
      }), createElement(Getter, {
        name: "getCollapsedRows",
        computed: getCollapsedRowsComputed$2
      }), createElement(Getter, {
        name: "rows",
        computed: groupedRowsComputed
      }), createElement(Getter, {
        name: "getRowId",
        computed: getRowIdComputed
      }), createElement(Getter, {
        name: "rows",
        computed: expandedGroupedRowsComputed$1
      }));
    }
  }]);

  return CustomGrouping;
}(PureComponent);
process.env.NODE_ENV !== "production" ? CustomGrouping.propTypes = {
  getChildGroups: func.isRequired,
  grouping: array,
  expandedGroups: array
} : void 0;
CustomGrouping.defaultProps = {
  grouping: undefined,
  expandedGroups: undefined
};

var SelectionState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(SelectionState, _React$PureComponent);

  function SelectionState(props) {
    var _this;

    _classCallCheck(this, SelectionState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SelectionState).call(this, props));
    _this.state = {
      selection: props.selection || props.defaultSelection
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      selection: function selection() {
        var onSelectionChange = _this.props.onSelectionChange;
        return onSelectionChange;
      }
    });
    _this.toggleSelection = stateHelper.applyFieldReducer.bind(stateHelper, 'selection', toggleSelection);
    return _this;
  }

  _createClass(SelectionState, [{
    key: "render",
    value: function render() {
      var selection = this.state.selection;
      return createElement(Plugin, {
        name: "SelectionState"
      }, createElement(Getter, {
        name: "selection",
        value: selection
      }), createElement(Action, {
        name: "toggleSelection",
        action: this.toggleSelection
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$selection = nextProps.selection,
          selection = _nextProps$selection === void 0 ? prevState.selection : _nextProps$selection;
      return {
        selection: selection
      };
    }
  }]);

  return SelectionState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? SelectionState.propTypes = {
  selection: array,
  defaultSelection: array,
  onSelectionChange: func
} : void 0;
SelectionState.defaultProps = {
  selection: undefined,
  defaultSelection: [],
  onSelectionChange: undefined
};

var rowsWithAvailableToSelectComputed = function rowsWithAvailableToSelectComputed(_ref) {
  var rows = _ref.rows,
      getRowId = _ref.getRowId,
      isGroupRow = _ref.isGroupRow;
  return rowsWithAvailableToSelect(rows, getRowId, isGroupRow);
};

var allSelectedComputed = function allSelectedComputed(_ref2) {
  var rows = _ref2.rows,
      selection = _ref2.selection;
  return allSelected(rows, selection);
};

var someSelectedComputed = function someSelectedComputed(_ref3) {
  var rows = _ref3.rows,
      selection = _ref3.selection;
  return someSelected(rows, selection);
};

var selectAllAvailableComputed = function selectAllAvailableComputed(_ref4) {
  var availableToSelect = _ref4.rows.availableToSelect;
  return !!availableToSelect.length;
};

var toggleSelectAll = function toggleSelectAll(state, _ref5, _ref6) {
  var availableToSelect = _ref5.rows.availableToSelect;
  var toggleSelection$$1 = _ref6.toggleSelection;
  toggleSelection$$1({
    rowIds: availableToSelect,
    state: state
  });
};

var unwrapRowsComputed = function unwrapRowsComputed(_ref7) {
  var rows = _ref7.rows;
  return unwrapSelectedRows(rows);
};

var pluginDependencies$6 = [{
  name: 'SelectionState'
}]; // eslint-disable-next-line react/prefer-stateless-function

var IntegratedSelection =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(IntegratedSelection, _React$PureComponent);

  function IntegratedSelection() {
    _classCallCheck(this, IntegratedSelection);

    return _possibleConstructorReturn(this, _getPrototypeOf(IntegratedSelection).apply(this, arguments));
  }

  _createClass(IntegratedSelection, [{
    key: "render",
    value: function render() {
      return createElement(Plugin, {
        name: "IntegratedSelection",
        dependencies: pluginDependencies$6
      }, createElement(Getter, {
        name: "rows",
        computed: rowsWithAvailableToSelectComputed
      }), createElement(Getter, {
        name: "allSelected",
        computed: allSelectedComputed
      }), createElement(Getter, {
        name: "someSelected",
        computed: someSelectedComputed
      }), createElement(Getter, {
        name: "selectAllAvailable",
        computed: selectAllAvailableComputed
      }), createElement(Action, {
        name: "toggleSelectAll",
        action: toggleSelectAll
      }), createElement(Getter, {
        name: "rows",
        computed: unwrapRowsComputed
      }));
    }
  }]);

  return IntegratedSelection;
}(PureComponent);

var columnExtensionValueGetter$3 = function columnExtensionValueGetter(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, 'sortingEnabled', defaultValue);
};

var SortingState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(SortingState, _React$PureComponent);

  function SortingState(props) {
    var _this;

    _classCallCheck(this, SortingState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SortingState).call(this, props));
    _this.state = {
      sorting: props.sorting || props.defaultSorting
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      sorting: function sorting() {
        var onSortingChange = _this.props.onSortingChange;
        return onSortingChange;
      }
    });
    _this.changeColumnSorting = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {
      var _this$props$sorting = _this.props.sorting,
          sorting = _this$props$sorting === void 0 ? prevState.sorting : _this$props$sorting;
      var persistentSortedColumns = getPersistentSortedColumns(sorting, props.columnExtensions);
      var keepOther = calculateKeepOther(prevState.sorting, payload.keepOther, persistentSortedColumns);
      return changeColumnSorting(prevState, _objectSpread({}, payload, {
        keepOther: keepOther
      }));
    });
    return _this;
  }

  _createClass(SortingState, [{
    key: "render",
    value: function render() {
      var sorting = this.state.sorting;
      var _this$props = this.props,
          columnExtensions = _this$props.columnExtensions,
          columnSortingEnabled = _this$props.columnSortingEnabled;
      return createElement(Plugin, {
        name: "SortingState"
      }, createElement(Getter, {
        name: "sorting",
        value: sorting
      }), createElement(Getter, {
        name: "isColumnSortingEnabled",
        value: columnExtensionValueGetter$3(columnExtensions, columnSortingEnabled)
      }), createElement(Action, {
        name: "changeColumnSorting",
        action: this.changeColumnSorting
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$sorting = nextProps.sorting,
          sorting = _nextProps$sorting === void 0 ? prevState.sorting : _nextProps$sorting;
      return {
        sorting: sorting
      };
    }
  }]);

  return SortingState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? SortingState.propTypes = {
  sorting: array,
  defaultSorting: array,
  onSortingChange: func,
  columnExtensions: array,
  columnSortingEnabled: bool
} : void 0;
SortingState.defaultProps = {
  sorting: undefined,
  defaultSorting: [],
  onSortingChange: undefined,
  columnExtensions: undefined,
  columnSortingEnabled: true
};

var pluginDependencies$7 = [{
  name: 'SortingState'
}];
var IntegratedSorting =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(IntegratedSorting, _React$PureComponent);

  function IntegratedSorting() {
    _classCallCheck(this, IntegratedSorting);

    return _possibleConstructorReturn(this, _getPrototypeOf(IntegratedSorting).apply(this, arguments));
  }

  _createClass(IntegratedSorting, [{
    key: "render",
    value: function render() {
      var columnExtensions = this.props.columnExtensions;

      var getColumnCompare = function getColumnCompare(columnName) {
        return getColumnExtension(columnExtensions, columnName).compare;
      };

      var rowsComputed = function rowsComputed(_ref) {
        var rows = _ref.rows,
            sorting = _ref.sorting,
            getCellValue = _ref.getCellValue,
            isGroupRow = _ref.isGroupRow,
            getRowLevelKey = _ref.getRowLevelKey;
        return sortedRows(rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey);
      };

      return createElement(Plugin, {
        name: "IntegratedSorting",
        dependencies: pluginDependencies$7
      }, createElement(Getter, {
        name: "rows",
        computed: rowsComputed
      }));
    }
  }]);

  return IntegratedSorting;
}(PureComponent);
process.env.NODE_ENV !== "production" ? IntegratedSorting.propTypes = {
  columnExtensions: array
} : void 0;
IntegratedSorting.defaultProps = {
  columnExtensions: undefined
};

var getTargetColumns = function getTargetColumns(payload, columns) {
  return payload.filter(function (item) {
    return item.type === 'column';
  }).map(function (item) {
    return columns.find(function (column) {
      return column.name === item.columnName;
    });
  });
};

var DragDropProvider$1 =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(DragDropProvider$$1, _React$PureComponent);

  function DragDropProvider$$1(props) {
    var _this;

    _classCallCheck(this, DragDropProvider$$1);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DragDropProvider$$1).call(this, props));
    _this.state = {
      payload: null,
      clientOffset: null
    };

    _this.change = function (_ref) {
      var payload = _ref.payload,
          clientOffset = _ref.clientOffset;
      return _this.setState({
        payload: payload,
        clientOffset: clientOffset
      });
    };

    return _this;
  }

  _createClass(DragDropProvider$$1, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          Container = _this$props.containerComponent,
          Column = _this$props.columnComponent;
      var _this$state = this.state,
          payload = _this$state.payload,
          clientOffset = _this$state.clientOffset;
      return createElement(Plugin, {
        name: "DragDropProvider"
      }, createElement(Getter, {
        name: "draggingEnabled",
        value: true
      }), createElement(Template, {
        name: "root"
      }, createElement(DragDropProvider, {
        onChange: this.change
      }, createElement(TemplatePlaceholder, null)), payload && createElement(TemplateConnector, null, function (_ref2) {
        var columns = _ref2.columns;
        return createElement(Container, {
          clientOffset: clientOffset
        }, getTargetColumns(payload, columns).map(function (column) {
          return createElement(Column, {
            key: column.name,
            column: column
          });
        }));
      })));
    }
  }]);

  return DragDropProvider$$1;
}(PureComponent);
process.env.NODE_ENV !== "production" ? DragDropProvider$1.propTypes = {
  containerComponent: func.isRequired,
  columnComponent: func.isRequired
} : void 0;
DragDropProvider$1.components = {
  containerComponent: 'Container',
  columnComponent: 'Column'
};

var pluginDependencies$8 = [{
  name: 'Table'
}];

var tableHeaderRowsComputed = function tableHeaderRowsComputed(_ref) {
  var tableHeaderRows = _ref.tableHeaderRows;
  return tableHeaderRowsWithReordering(tableHeaderRows);
};

var TableColumnReorderingRaw =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableColumnReorderingRaw, _React$PureComponent);

  function TableColumnReorderingRaw(props) {
    var _this;

    _classCallCheck(this, TableColumnReorderingRaw);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TableColumnReorderingRaw).call(this, props));
    _this.state = {
      order: props.defaultOrder,
      sourceColumnIndex: -1,
      targetColumnIndex: -1
    };
    _this.onOver = _this.handleOver.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onLeave = _this.handleLeave.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onDrop = _this.handleDrop.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(TableColumnReorderingRaw, [{
    key: "getState",
    value: function getState() {
      var orderState = this.state.order;
      var _this$props$order = this.props.order,
          order = _this$props$order === void 0 ? orderState : _this$props$order;
      return _objectSpread({}, this.state, {
        order: order
      });
    }
  }, {
    key: "getDraftOrder",
    value: function getDraftOrder() {
      var _this$getState = this.getState(),
          order = _this$getState.order,
          sourceColumnIndex = _this$getState.sourceColumnIndex,
          targetColumnIndex = _this$getState.targetColumnIndex;

      return draftOrder(order, sourceColumnIndex, targetColumnIndex);
    }
  }, {
    key: "getAvailableColumns",
    value: function getAvailableColumns() {
      var _this2 = this;

      return this.getDraftOrder().filter(function (columnName) {
        return !!_this2.cellDimensionGetters[columnName];
      });
    }
  }, {
    key: "cacheCellDimensions",
    value: function cacheCellDimensions() {
      var _this3 = this;

      this.cellDimensions = this.cellDimensions && this.cellDimensions.length ? this.cellDimensions : this.getAvailableColumns().map(function (columnName) {
        return _this3.cellDimensionGetters[columnName]();
      });
    }
  }, {
    key: "resetCellDimensions",
    value: function resetCellDimensions() {
      this.cellDimensions = [];
    }
  }, {
    key: "ensureCellDimensionGetters",
    value: function ensureCellDimensionGetters(tableColumns) {
      var _this4 = this;

      Object.keys(this.cellDimensionGetters).forEach(function (columnName) {
        var columnIndex = tableColumns.findIndex(function (_ref2) {
          var type = _ref2.type,
              column = _ref2.column;
          return type === TABLE_DATA_TYPE && column.name === columnName;
        });

        if (columnIndex === -1) {
          delete _this4.cellDimensionGetters[columnName];
        }
      });
    }
  }, {
    key: "storeCellDimensionsGetter",
    value: function storeCellDimensionsGetter(tableColumn, getter, tableColumns) {
      if (tableColumn.type === TABLE_DATA_TYPE) {
        this.cellDimensionGetters[tableColumn.column.name] = getter;
      }

      this.ensureCellDimensionGetters(tableColumns);
    }
  }, {
    key: "handleOver",
    value: function handleOver(_ref3) {
      var payload = _ref3.payload,
          x = _ref3.clientOffset.x;
      var sourceColumnName = payload[0].columnName;
      var availableColumns = this.getAvailableColumns();
      var relativeSourceColumnIndex = availableColumns.indexOf(sourceColumnName);
      if (relativeSourceColumnIndex === -1) return;
      this.cacheCellDimensions();
      var cellDimensions = this.cellDimensions;
      var overlappedColumns = cellDimensions.filter(function (_ref4) {
        var left = _ref4.left,
            right = _ref4.right;
        return left <= x && x <= right;
      });
      if (overlappedColumns.length > 1) return;
      var relativeTargetIndex = getTableTargetColumnIndex(cellDimensions, relativeSourceColumnIndex, x);
      if (relativeTargetIndex === -1) return;

      var _this$getState2 = this.getState(),
          prevSourceColumnIndex = _this$getState2.sourceColumnIndex,
          prevTargetColumnIndex = _this$getState2.targetColumnIndex;

      var draftOrder$$1 = this.getDraftOrder();
      var targetColumnIndex = draftOrder$$1.indexOf(availableColumns[relativeTargetIndex]);
      if (targetColumnIndex === prevTargetColumnIndex) return;
      var sourceColumnIndex = prevSourceColumnIndex === -1 ? draftOrder$$1.indexOf(sourceColumnName) : prevSourceColumnIndex;
      this.setState({
        sourceColumnIndex: sourceColumnIndex,
        targetColumnIndex: targetColumnIndex
      });
    }
  }, {
    key: "handleLeave",
    value: function handleLeave() {
      this.setState({
        sourceColumnIndex: -1,
        targetColumnIndex: -1
      });
      this.resetCellDimensions();
    }
  }, {
    key: "handleDrop",
    value: function handleDrop() {
      var _this$getState3 = this.getState(),
          sourceColumnIndex = _this$getState3.sourceColumnIndex,
          targetColumnIndex = _this$getState3.targetColumnIndex,
          order = _this$getState3.order;

      var onOrderChange = this.props.onOrderChange;
      if (sourceColumnIndex === -1 && targetColumnIndex === -1) return;
      var nextOrder = changeColumnOrder(order, {
        sourceColumnName: order[sourceColumnIndex],
        targetColumnName: order[targetColumnIndex]
      });
      this.setState({
        order: nextOrder,
        sourceColumnIndex: -1,
        targetColumnIndex: -1
      });

      if (onOrderChange) {
        onOrderChange(nextOrder);
      }

      this.resetCellDimensions();
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var _this$props = this.props,
          Container = _this$props.tableContainerComponent,
          Row = _this$props.rowComponent,
          Cell = _this$props.cellComponent;

      var columnsComputed = function columnsComputed(_ref5) {
        var tableColumns = _ref5.tableColumns;
        return orderedColumns(tableColumns, _this5.getDraftOrder());
      };

      this.cellDimensionGetters = {};
      return createElement(Plugin, {
        name: "TableColumnReordering",
        dependencies: pluginDependencies$8
      }, createElement(Getter, {
        name: "tableColumns",
        computed: columnsComputed
      }), createElement(Getter, {
        name: "tableHeaderRows",
        computed: tableHeaderRowsComputed
      }), createElement(Template, {
        name: "table"
      }, function (params) {
        return createElement(Container, _extends({}, params, {
          onOver: _this5.onOver,
          onLeave: _this5.onLeave,
          onDrop: _this5.onDrop
        }), createElement(TemplatePlaceholder, null));
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref6) {
          var tableRow = _ref6.tableRow;
          return tableRow.type === TABLE_REORDERING_TYPE;
        }
      }, function (params) {
        return createElement(Row, params);
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref7) {
          var tableRow = _ref7.tableRow;
          return tableRow.type === TABLE_REORDERING_TYPE;
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref8) {
          var tableColumns = _ref8.tableColumns;
          return createElement(Cell, _extends({}, params, {
            getCellDimensions: function getCellDimensions(getter) {
              return _this5.storeCellDimensionsGetter(params.tableColumn, getter, tableColumns);
            }
          }));
        });
      }));
    }
  }]);

  return TableColumnReorderingRaw;
}(PureComponent);

process.env.NODE_ENV !== "production" ? TableColumnReorderingRaw.propTypes = {
  order: arrayOf(string),
  defaultOrder: arrayOf(string),
  onOrderChange: func,
  tableContainerComponent: func.isRequired,
  rowComponent: func.isRequired,
  cellComponent: func.isRequired
} : void 0;
TableColumnReorderingRaw.defaultProps = {
  order: undefined,
  defaultOrder: [],
  onOrderChange: undefined
};
TableColumnReorderingRaw.components = {
  tableContainerComponent: 'TableContainer',
  rowComponent: 'Row',
  cellComponent: 'Cell'
};

var TableContainer = function TableContainer(_ref9) {
  var onOver = _ref9.onOver,
      onLeave = _ref9.onLeave,
      onDrop = _ref9.onDrop,
      children = _ref9.children;
  return createElement(DropTarget, {
    onOver: onOver,
    onLeave: onLeave,
    onDrop: onDrop
  }, children);
};

var TableColumnReordering = withComponents({
  TableContainer: TableContainer
})(TableColumnReorderingRaw);

var RowPlaceholder = function RowPlaceholder(props) {
  return createElement(TemplatePlaceholder, {
    name: "tableRow",
    params: props
  });
};

var CellPlaceholder = function CellPlaceholder(props) {
  return createElement(TemplatePlaceholder, {
    name: "tableCell",
    params: props
  });
};

var tableHeaderRows = [];

var tableBodyRowsComputed = function tableBodyRowsComputed(_ref) {
  var rows = _ref.rows,
      getRowId = _ref.getRowId;
  return tableRowsWithDataRows(rows, getRowId);
};

var tableFooterRows = [];
var defaultMessages = {
  noData: 'No data'
};
var Table =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(Table, _React$PureComponent);

  function Table(props) {
    var _this;

    _classCallCheck(this, Table);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Table).call(this, props));
    _this.tableColumnsComputed = memoize(function (columnExtensions) {
      return function (_ref2) {
        var columns = _ref2.columns;
        return tableColumnsWithDataRows(columns, columnExtensions);
      };
    });
    return _this;
  }

  _createClass(Table, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          Layout = _this$props.layoutComponent,
          Cell = _this$props.cellComponent,
          Row = _this$props.rowComponent,
          NoDataRow = _this$props.noDataRowComponent,
          NoDataCell = _this$props.noDataCellComponent,
          StubRow = _this$props.stubRowComponent,
          StubCell = _this$props.stubCellComponent,
          StubHeaderCell = _this$props.stubHeaderCellComponent,
          columnExtensions = _this$props.columnExtensions,
          messages = _this$props.messages,
          containerComponent = _this$props.containerComponent,
          tableComponent = _this$props.tableComponent,
          headComponent = _this$props.headComponent,
          bodyComponent = _this$props.bodyComponent,
          footerComponent = _this$props.footerComponent;
      var getMessage = getMessagesFormatter(_objectSpread({}, defaultMessages, messages));
      var tableColumnsComputed = this.tableColumnsComputed(columnExtensions);
      return createElement(Plugin, {
        name: "Table"
      }, createElement(Getter, {
        name: "tableHeaderRows",
        value: tableHeaderRows
      }), createElement(Getter, {
        name: "tableBodyRows",
        computed: tableBodyRowsComputed
      }), createElement(Getter, {
        name: "tableFooterRows",
        value: tableFooterRows
      }), createElement(Getter, {
        name: "tableColumns",
        computed: tableColumnsComputed
      }), createElement(Getter, {
        name: "getTableCellColSpan",
        value: tableCellColSpanGetter
      }), createElement(Template, {
        name: "body"
      }, createElement(TemplatePlaceholder, {
        name: "table"
      })), createElement(Template, {
        name: "table"
      }, createElement(TemplateConnector, null, function (_ref3) {
        var headerRows = _ref3.tableHeaderRows,
            bodyRows = _ref3.tableBodyRows,
            footerRows = _ref3.tableFooterRows,
            columns = _ref3.tableColumns,
            getTableCellColSpan = _ref3.getTableCellColSpan;
        return createElement(Layout, {
          tableComponent: tableComponent,
          headComponent: headComponent,
          bodyComponent: bodyComponent,
          footerComponent: footerComponent,
          containerComponent: containerComponent,
          headerRows: headerRows,
          bodyRows: bodyRows,
          footerRows: footerRows,
          columns: columns,
          rowComponent: RowPlaceholder,
          cellComponent: CellPlaceholder,
          getCellColSpan: getTableCellColSpan
        });
      })), createElement(Template, {
        name: "tableCell"
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref4) {
          var headerRows = _ref4.tableHeaderRows;
          return isHeaderStubTableCell(params.tableRow, headerRows) ? createElement(StubHeaderCell, params) : createElement(StubCell, params);
        });
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref5) {
          var tableRow = _ref5.tableRow,
              tableColumn = _ref5.tableColumn;
          return isDataTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref6) {
          var getCellValue = _ref6.getCellValue;
          var columnName = params.tableColumn.column.name;
          var value = getCellValue(params.tableRow.row, columnName);
          return createElement(TemplatePlaceholder, {
            name: "valueFormatter",
            params: {
              row: params.tableRow.row,
              column: params.tableColumn.column,
              value: value
            }
          }, function (content) {
            return createElement(Cell, _extends({}, params, {
              row: params.tableRow.row,
              column: params.tableColumn.column,
              value: value
            }), content);
          });
        });
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref7) {
          var tableRow = _ref7.tableRow;
          return isNoDataTableRow(tableRow);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref8) {
          var tableColumns = _ref8.tableColumns;

          if (isNoDataTableCell(params.tableColumn, tableColumns)) {
            return createElement(NoDataCell, _extends({}, params, {
              getMessage: getMessage
            }));
          }

          return null;
        });
      }), createElement(Template, {
        name: "tableRow"
      }, function (params) {
        return createElement(StubRow, params);
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref9) {
          var tableRow = _ref9.tableRow;
          return isDataTableRow(tableRow);
        }
      }, function (params) {
        return createElement(Row, _extends({}, params, {
          row: params.tableRow.row
        }));
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref10) {
          var tableRow = _ref10.tableRow;
          return isNoDataTableRow(tableRow);
        }
      }, function (params) {
        return createElement(NoDataRow, params);
      }));
    }
  }]);

  return Table;
}(PureComponent);
Table.COLUMN_TYPE = TABLE_DATA_TYPE;
Table.ROW_TYPE = TABLE_DATA_TYPE;
Table.NODATA_ROW_TYPE = TABLE_NODATA_TYPE;
process.env.NODE_ENV !== "production" ? Table.propTypes = {
  layoutComponent: func.isRequired,
  tableComponent: func.isRequired,
  headComponent: func.isRequired,
  bodyComponent: func.isRequired,
  footerComponent: func.isRequired,
  containerComponent: func.isRequired,
  cellComponent: func.isRequired,
  rowComponent: func.isRequired,
  noDataCellComponent: func.isRequired,
  noDataRowComponent: func.isRequired,
  stubRowComponent: func.isRequired,
  stubCellComponent: func.isRequired,
  stubHeaderCellComponent: func.isRequired,
  columnExtensions: array,
  messages: shape({
    noData: string
  })
} : void 0;
Table.defaultProps = {
  columnExtensions: undefined,
  messages: {}
};
Table.components = {
  tableComponent: 'Table',
  headComponent: 'TableHead',
  bodyComponent: 'TableBody',
  footerComponent: 'TableFooter',
  containerComponent: 'Container',
  layoutComponent: 'Layout',
  rowComponent: 'Row',
  cellComponent: 'Cell',
  noDataRowComponent: 'NoDataRow',
  noDataCellComponent: 'NoDataCell',
  stubRowComponent: 'StubRow',
  stubCellComponent: 'StubCell',
  stubHeaderCellComponent: 'StubHeaderCell'
};

var TableSelection =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableSelection, _React$PureComponent);

  function TableSelection() {
    _classCallCheck(this, TableSelection);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableSelection).apply(this, arguments));
  }

  _createClass(TableSelection, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          highlightRow = _this$props.highlightRow,
          selectByRowClick = _this$props.selectByRowClick,
          showSelectionColumn = _this$props.showSelectionColumn,
          showSelectAll = _this$props.showSelectAll,
          HeaderCell = _this$props.headerCellComponent,
          Cell = _this$props.cellComponent,
          Row = _this$props.rowComponent,
          selectionColumnWidth = _this$props.selectionColumnWidth;

      var tableColumnsComputed = function tableColumnsComputed(_ref) {
        var tableColumns = _ref.tableColumns;
        return tableColumnsWithSelection(tableColumns, selectionColumnWidth);
      };

      return createElement(Plugin, {
        name: "TableSelection",
        dependencies: [{
          name: 'Table'
        }, {
          name: 'SelectionState'
        }, {
          name: 'IntegratedSelection',
          optional: !showSelectAll
        }]
      }, showSelectionColumn && createElement(Getter, {
        name: "tableColumns",
        computed: tableColumnsComputed
      }), showSelectionColumn && showSelectAll && createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref2) {
          var tableRow = _ref2.tableRow,
              tableColumn = _ref2.tableColumn;
          return isSelectAllTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref3, _ref4) {
          var selectAllAvailable = _ref3.selectAllAvailable,
              allSelected$$1 = _ref3.allSelected,
              someSelected$$1 = _ref3.someSelected;
          var toggleSelectAll = _ref4.toggleSelectAll;
          return createElement(HeaderCell, _extends({}, params, {
            disabled: !selectAllAvailable,
            allSelected: allSelected$$1,
            someSelected: someSelected$$1,
            onToggle: function onToggle(select) {
              return toggleSelectAll(select);
            }
          }));
        });
      }), showSelectionColumn && createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref5) {
          var tableRow = _ref5.tableRow,
              tableColumn = _ref5.tableColumn;
          return isSelectTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref6, _ref7) {
          var selection = _ref6.selection;
          var toggleSelection$$1 = _ref7.toggleSelection;
          return createElement(Cell, _extends({}, params, {
            row: params.tableRow.row,
            selected: selection.indexOf(params.tableRow.rowId) !== -1,
            onToggle: function onToggle() {
              return toggleSelection$$1({
                rowIds: [params.tableRow.rowId]
              });
            }
          }));
        });
      }), (highlightRow || selectByRowClick) && createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref8) {
          var tableRow = _ref8.tableRow;
          return isDataTableRow(tableRow);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref9, _ref10) {
          var selection = _ref9.selection;
          var toggleSelection$$1 = _ref10.toggleSelection;
          return createElement(Row, _extends({}, params, {
            selectByRowClick: selectByRowClick,
            selected: highlightRow && selection.indexOf(params.tableRow.rowId) !== -1,
            onToggle: function onToggle() {
              return toggleSelection$$1({
                rowIds: [params.tableRow.rowId]
              });
            }
          }));
        });
      }));
    }
  }]);

  return TableSelection;
}(PureComponent);
TableSelection.COLUMN_TYPE = TABLE_SELECT_TYPE;
process.env.NODE_ENV !== "production" ? TableSelection.propTypes = {
  headerCellComponent: func.isRequired,
  cellComponent: func.isRequired,
  rowComponent: func.isRequired,
  highlightRow: bool,
  selectByRowClick: bool,
  showSelectAll: bool,
  showSelectionColumn: bool,
  selectionColumnWidth: number.isRequired
} : void 0;
TableSelection.defaultProps = {
  highlightRow: false,
  selectByRowClick: false,
  showSelectAll: false,
  showSelectionColumn: true
};
TableSelection.components = {
  rowComponent: 'Row',
  cellComponent: 'Cell',
  headerCellComponent: 'HeaderCell'
};

var RowDetailState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(RowDetailState, _React$PureComponent);

  function RowDetailState(props) {
    var _this;

    _classCallCheck(this, RowDetailState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RowDetailState).call(this, props));
    _this.state = {
      expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      expandedRowIds: function expandedRowIds() {
        var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;
        return onExpandedRowIdsChange;
      }
    });
    _this.toggleDetailRowExpanded = stateHelper.applyFieldReducer.bind(stateHelper, 'expandedRowIds', toggleDetailRowExpanded);
    return _this;
  }

  _createClass(RowDetailState, [{
    key: "render",
    value: function render() {
      var expandedRowIds = this.state.expandedRowIds;
      return createElement(Plugin, {
        name: "RowDetailState"
      }, createElement(Getter, {
        name: "expandedDetailRowIds",
        value: expandedRowIds
      }), createElement(Action, {
        name: "toggleDetailRowExpanded",
        action: this.toggleDetailRowExpanded
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$expandedRo = nextProps.expandedRowIds,
          expandedRowIds = _nextProps$expandedRo === void 0 ? prevState.expandedRowIds : _nextProps$expandedRo;
      return {
        expandedRowIds: expandedRowIds
      };
    }
  }]);

  return RowDetailState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? RowDetailState.propTypes = {
  expandedRowIds: array,
  defaultExpandedRowIds: array,
  onExpandedRowIdsChange: func
} : void 0;
RowDetailState.defaultProps = {
  expandedRowIds: undefined,
  defaultExpandedRowIds: [],
  onExpandedRowIdsChange: undefined
};

var getCellColSpanComputed = function getCellColSpanComputed(_ref) {
  var getTableCellColSpan = _ref.getTableCellColSpan;
  return tableDetailCellColSpanGetter(getTableCellColSpan);
};

var pluginDependencies$9 = [{
  name: 'RowDetailState'
}, {
  name: 'Table'
}];
var TableRowDetail =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableRowDetail, _React$PureComponent);

  function TableRowDetail() {
    _classCallCheck(this, TableRowDetail);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableRowDetail).apply(this, arguments));
  }

  _createClass(TableRowDetail, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          rowHeight = _this$props.rowHeight,
          Content = _this$props.contentComponent,
          ToggleCell = _this$props.toggleCellComponent,
          Cell = _this$props.cellComponent,
          Row = _this$props.rowComponent,
          toggleColumnWidth = _this$props.toggleColumnWidth;

      var tableColumnsComputed = function tableColumnsComputed(_ref2) {
        var tableColumns = _ref2.tableColumns;
        return tableColumnsWithDetail(tableColumns, toggleColumnWidth);
      };

      var tableBodyRowsComputed = function tableBodyRowsComputed(_ref3) {
        var tableBodyRows = _ref3.tableBodyRows,
            expandedDetailRowIds = _ref3.expandedDetailRowIds;
        return tableRowsWithExpandedDetail(tableBodyRows, expandedDetailRowIds, rowHeight);
      };

      return createElement(Plugin, {
        name: "TableRowDetail",
        dependencies: pluginDependencies$9
      }, createElement(Getter, {
        name: "tableColumns",
        computed: tableColumnsComputed
      }), createElement(Getter, {
        name: "tableBodyRows",
        computed: tableBodyRowsComputed
      }), createElement(Getter, {
        name: "getTableCellColSpan",
        computed: getCellColSpanComputed
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref4) {
          var tableRow = _ref4.tableRow,
              tableColumn = _ref4.tableColumn;
          return isDetailToggleTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref5, _ref6) {
          var expandedDetailRowIds = _ref5.expandedDetailRowIds;
          var toggleDetailRowExpanded$$1 = _ref6.toggleDetailRowExpanded;
          return createElement(ToggleCell, _extends({}, params, {
            row: params.tableRow.row,
            expanded: isDetailRowExpanded(expandedDetailRowIds, params.tableRow.rowId),
            onToggle: function onToggle() {
              return toggleDetailRowExpanded$$1({
                rowId: params.tableRow.rowId
              });
            }
          }));
        });
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref7) {
          var tableRow = _ref7.tableRow;
          return isDetailTableRow(tableRow);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref8) {
          var tableColumns = _ref8.tableColumns;

          if (isDetailTableCell(params.tableColumn, tableColumns)) {
            return createElement(Cell, _extends({}, params, {
              row: params.tableRow.row
            }), createElement(Content, {
              row: params.tableRow.row
            }));
          }

          return null;
        });
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref9) {
          var tableRow = _ref9.tableRow;
          return isDetailTableRow(tableRow);
        }
      }, function (params) {
        return createElement(Row, _extends({}, params, {
          row: params.tableRow.row
        }));
      }));
    }
  }]);

  return TableRowDetail;
}(PureComponent);
TableRowDetail.ROW_TYPE = TABLE_DETAIL_TYPE;
TableRowDetail.COLUMN_TYPE = TABLE_DETAIL_TYPE;
process.env.NODE_ENV !== "production" ? TableRowDetail.propTypes = {
  contentComponent: func,
  toggleCellComponent: func.isRequired,
  cellComponent: func.isRequired,
  rowComponent: func.isRequired,
  toggleColumnWidth: number.isRequired,
  rowHeight: number
} : void 0;
TableRowDetail.defaultProps = {
  contentComponent: function contentComponent() {
    return null;
  },
  rowHeight: undefined
};
TableRowDetail.components = {
  rowComponent: 'Row',
  cellComponent: 'Cell',
  toggleCellComponent: 'ToggleCell'
};

var pluginDependencies$a = [{
  name: 'GroupingState'
}, {
  name: 'Table'
}, {
  name: 'DataTypeProvider',
  optional: true
}];

var tableBodyRowsComputed$1 = function tableBodyRowsComputed(_ref) {
  var tableBodyRows = _ref.tableBodyRows,
      isGroupRow = _ref.isGroupRow;
  return tableRowsWithGrouping(tableBodyRows, isGroupRow);
};

var getCellColSpanComputed$1 = function getCellColSpanComputed(_ref2) {
  var getTableCellColSpan = _ref2.getTableCellColSpan;
  return tableGroupCellColSpanGetter(getTableCellColSpan);
};

var showColumnWhenGroupedGetter = function showColumnWhenGroupedGetter(showColumnsWhenGrouped) {
  var columnExtensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var map = columnExtensions.reduce(function (acc, columnExtension) {
    acc[columnExtension.columnName] = columnExtension.showWhenGrouped;
    return acc;
  }, {});
  return function (columnName) {
    return map[columnName] || showColumnsWhenGrouped;
  };
};

var TableGroupRow =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableGroupRow, _React$PureComponent);

  function TableGroupRow() {
    _classCallCheck(this, TableGroupRow);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableGroupRow).apply(this, arguments));
  }

  _createClass(TableGroupRow, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          GroupCell = _this$props.cellComponent,
          Content = _this$props.contentComponent,
          Icon = _this$props.iconComponent,
          GroupRow = _this$props.rowComponent,
          GroupIndentCell = _this$props.indentCellComponent,
          indentColumnWidth = _this$props.indentColumnWidth,
          showColumnsWhenGrouped = _this$props.showColumnsWhenGrouped,
          columnExtensions = _this$props.columnExtensions;

      var tableColumnsComputed = function tableColumnsComputed(_ref3) {
        var columns = _ref3.columns,
            tableColumns = _ref3.tableColumns,
            grouping = _ref3.grouping,
            draftGrouping = _ref3.draftGrouping;
        return tableColumnsWithGrouping(columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGroupedGetter(showColumnsWhenGrouped, columnExtensions));
      };

      return createElement(Plugin, {
        name: "TableGroupRow",
        dependencies: pluginDependencies$a
      }, createElement(Getter, {
        name: "tableColumns",
        computed: tableColumnsComputed
      }), createElement(Getter, {
        name: "tableBodyRows",
        computed: tableBodyRowsComputed$1
      }), createElement(Getter, {
        name: "getTableCellColSpan",
        computed: getCellColSpanComputed$1
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref4) {
          var tableRow = _ref4.tableRow;
          return isGroupTableRow(tableRow);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref5, _ref6) {
          var grouping = _ref5.grouping,
              expandedGroups = _ref5.expandedGroups;
          var toggleGroupExpanded = _ref6.toggleGroupExpanded;

          if (isGroupTableCell(params.tableRow, params.tableColumn)) {
            return createElement(TemplatePlaceholder, {
              name: "valueFormatter",
              params: {
                column: params.tableColumn.column,
                value: params.tableRow.row.value
              }
            }, function (content) {
              return createElement(GroupCell, _extends({}, params, {
                contentComponent: Content,
                iconComponent: Icon,
                row: params.tableRow.row,
                column: params.tableColumn.column,
                expanded: expandedGroups.indexOf(params.tableRow.row.compoundKey) !== -1,
                onToggle: function onToggle() {
                  return toggleGroupExpanded({
                    groupKey: params.tableRow.row.compoundKey
                  });
                }
              }), content);
            });
          }

          if (isGroupIndentTableCell(params.tableRow, params.tableColumn, grouping)) {
            if (GroupIndentCell) {
              return createElement(GroupIndentCell, _extends({}, params, {
                row: params.tableRow.row,
                column: params.tableColumn.column
              }));
            }

            return createElement(TemplatePlaceholder, null);
          }

          return null;
        });
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref7) {
          var tableRow = _ref7.tableRow;
          return isGroupTableRow(tableRow);
        }
      }, function (params) {
        return createElement(GroupRow, _extends({}, params, {
          row: params.tableRow.row
        }));
      }));
    }
  }]);

  return TableGroupRow;
}(PureComponent);
TableGroupRow.ROW_TYPE = TABLE_GROUP_TYPE;
TableGroupRow.COLUMN_TYPE = TABLE_GROUP_TYPE;
process.env.NODE_ENV !== "production" ? TableGroupRow.propTypes = {
  cellComponent: func.isRequired,
  contentComponent: func.isRequired,
  iconComponent: func.isRequired,
  rowComponent: func.isRequired,
  indentCellComponent: func,
  indentColumnWidth: number.isRequired,
  showColumnsWhenGrouped: bool,
  columnExtensions: array
} : void 0;
TableGroupRow.defaultProps = {
  indentCellComponent: null,
  showColumnsWhenGrouped: false,
  columnExtensions: undefined
};
TableGroupRow.components = {
  rowComponent: 'Row',
  cellComponent: 'Cell',
  contentComponent: 'Content',
  iconComponent: 'Icon'
};

var tableHeaderRowsComputed$1 = function tableHeaderRowsComputed(_ref) {
  var tableHeaderRows = _ref.tableHeaderRows;
  return tableRowsWithHeading(tableHeaderRows);
};

var TableHeaderRow =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableHeaderRow, _React$PureComponent);

  function TableHeaderRow() {
    _classCallCheck(this, TableHeaderRow);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableHeaderRow).apply(this, arguments));
  }

  _createClass(TableHeaderRow, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          showSortingControls = _this$props.showSortingControls,
          showGroupingControls = _this$props.showGroupingControls,
          HeaderCell = _this$props.cellComponent,
          HeaderRow = _this$props.rowComponent,
          Content = _this$props.contentComponent,
          SortLabel = _this$props.sortLabelComponent,
          GroupButton = _this$props.groupButtonComponent,
          Title = _this$props.titleComponent,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(messages);
      return createElement(Plugin, {
        name: "TableHeaderRow",
        dependencies: [{
          name: 'Table'
        }, {
          name: 'SortingState',
          optional: !showSortingControls
        }, {
          name: 'GroupingState',
          optional: !showGroupingControls
        }, {
          name: 'DragDropProvider',
          optional: true
        }, {
          name: 'TableColumnResizing',
          optional: true
        }]
      }, createElement(Getter, {
        name: "tableHeaderRows",
        computed: tableHeaderRowsComputed$1
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref2) {
          var tableRow = _ref2.tableRow,
              tableColumn = _ref2.tableColumn;
          return isHeadingTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref3, _ref4) {
          var sorting = _ref3.sorting,
              tableColumns = _ref3.tableColumns,
              draggingEnabled = _ref3.draggingEnabled,
              tableColumnResizingEnabled = _ref3.tableColumnResizingEnabled,
              isColumnSortingEnabled = _ref3.isColumnSortingEnabled,
              isColumnGroupingEnabled = _ref3.isColumnGroupingEnabled;
          var changeColumnSorting$$1 = _ref4.changeColumnSorting,
              changeColumnGrouping$$1 = _ref4.changeColumnGrouping,
              changeTableColumnWidth$$1 = _ref4.changeTableColumnWidth,
              draftTableColumnWidth$$1 = _ref4.draftTableColumnWidth,
              cancelTableColumnWidthDraft$$1 = _ref4.cancelTableColumnWidthDraft;
          var _params$tableColumn$c = params.tableColumn.column,
              columnName = _params$tableColumn$c.name,
              columnTitle = _params$tableColumn$c.title;
          var atLeastOneDataColumn = tableColumns.filter(function (_ref5) {
            var type = _ref5.type;
            return type === TABLE_DATA_TYPE;
          }).length > 1;
          var sortingEnabled = isColumnSortingEnabled && isColumnSortingEnabled(columnName);
          var groupingEnabled = isColumnGroupingEnabled && isColumnGroupingEnabled(columnName) && atLeastOneDataColumn;
          return createElement(HeaderCell, _extends({}, params, {
            column: params.tableColumn.column,
            getMessage: getMessage,
            draggingEnabled: draggingEnabled && atLeastOneDataColumn,
            resizingEnabled: tableColumnResizingEnabled,
            onWidthChange: function onWidthChange(_ref6) {
              var shift = _ref6.shift;
              return changeTableColumnWidth$$1({
                columnName: columnName,
                shift: shift
              });
            },
            onWidthDraft: function onWidthDraft(_ref7) {
              var shift = _ref7.shift;
              return draftTableColumnWidth$$1({
                columnName: columnName,
                shift: shift
              });
            },
            onWidthDraftCancel: function onWidthDraftCancel() {
              return cancelTableColumnWidthDraft$$1();
            } // @deprecated
            ,
            sortingEnabled: sortingEnabled // @deprecated
            ,
            groupingEnabled: groupingEnabled // @deprecated
            ,
            showSortingControls: showSortingControls // @deprecated
            ,
            showGroupingControls: showGroupingControls // @deprecated
            ,
            sortingDirection: showSortingControls && sorting !== undefined ? getColumnSortingDirection(sorting, columnName) : undefined // @deprecated
            ,
            onSort: function onSort(_ref8) {
              var direction = _ref8.direction,
                  keepOther = _ref8.keepOther;
              return changeColumnSorting$$1({
                columnName: columnName,
                direction: direction,
                keepOther: keepOther
              });
            } // @deprecated
            ,
            onGroup: function onGroup() {
              return changeColumnGrouping$$1({
                columnName: columnName
              });
            } // @deprecated
            ,
            before: createElement(TemplatePlaceholder, {
              name: "tableHeaderCellBefore",
              params: {
                column: params.tableColumn.column
              }
            })
          }), createElement(TemplatePlaceholder, {
            name: "tableHeaderCellBefore",
            params: {
              column: params.tableColumn.column
            }
          }), createElement(Content, {
            column: params.tableColumn.column,
            align: params.tableColumn.align
          }, showSortingControls ? createElement(SortLabel, {
            column: params.tableColumn.column,
            align: params.tableColumn.align,
            direction: getColumnSortingDirection(sorting, columnName),
            disabled: !sortingEnabled,
            onSort: function onSort(_ref9) {
              var direction = _ref9.direction,
                  keepOther = _ref9.keepOther;
              changeColumnSorting$$1({
                columnName: columnName,
                direction: direction,
                keepOther: keepOther
              });
            },
            getMessage: getMessage
          }, createElement(Title, null, columnTitle || columnName)) : createElement(Title, null, columnTitle || columnName)), showGroupingControls ? createElement(GroupButton, {
            disabled: !groupingEnabled,
            onGroup: function onGroup() {
              return changeColumnGrouping$$1({
                columnName: columnName
              });
            }
          }) : null);
        });
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref10) {
          var tableRow = _ref10.tableRow;
          return isHeadingTableRow(tableRow);
        }
      }, function (params) {
        return createElement(HeaderRow, params);
      }));
    }
  }]);

  return TableHeaderRow;
}(PureComponent);
TableHeaderRow.ROW_TYPE = TABLE_HEADING_TYPE;
process.env.NODE_ENV !== "production" ? TableHeaderRow.propTypes = {
  showSortingControls: bool,
  showGroupingControls: bool,
  cellComponent: func.isRequired,
  contentComponent: func.isRequired,
  rowComponent: func.isRequired,
  titleComponent: func.isRequired,
  sortLabelComponent: func.isRequired,
  groupButtonComponent: func.isRequired,
  messages: object
} : void 0;
TableHeaderRow.defaultProps = {
  showSortingControls: false,
  showGroupingControls: false,
  messages: null
};
TableHeaderRow.components = {
  cellComponent: 'Cell',
  rowComponent: 'Row',
  contentComponent: 'Content',
  sortLabelComponent: 'SortLabel',
  titleComponent: 'Title',
  groupButtonComponent: 'GroupButton'
};

var CellPlaceholder$1 = function CellPlaceholder(props) {
  return createElement(TemplatePlaceholder, {
    params: props
  });
};

var TableBandHeader =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableBandHeader, _React$PureComponent);

  function TableBandHeader() {
    _classCallCheck(this, TableBandHeader);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableBandHeader).apply(this, arguments));
  }

  _createClass(TableBandHeader, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          Cell = _this$props.cellComponent,
          Row = _this$props.rowComponent,
          HeaderCell = _this$props.bandedHeaderCellComponent,
          InvisibleCell = _this$props.invisibleCellComponent,
          columnBands = _this$props.columnBands;

      var tableHeaderRowsComputed = function tableHeaderRowsComputed(_ref) {
        var tableHeaderRows = _ref.tableHeaderRows,
            tableColumns = _ref.tableColumns;
        return tableRowsWithBands(tableHeaderRows, columnBands, tableColumns);
      };

      var tableHeaderColumnChainsComputed = function tableHeaderColumnChainsComputed(_ref2) {
        var tableHeaderRows = _ref2.tableHeaderRows,
            tableColumns = _ref2.tableColumns;
        return tableHeaderColumnChainsWithBands(tableHeaderRows, tableColumns, columnBands);
      };

      return createElement(Plugin, {
        name: "TableBandHeader",
        dependencies: [{
          name: 'Table'
        }, {
          name: 'TableHeaderRow'
        }, {
          name: 'TableSelection',
          optional: true
        }, {
          name: 'TableEditColumn',
          optional: true
        }]
      }, createElement(Getter, {
        name: "tableHeaderRows",
        computed: tableHeaderRowsComputed
      }), createElement(Getter, {
        name: "tableHeaderColumnChains",
        computed: tableHeaderColumnChainsComputed
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref3) {
          var tableRow = _ref3.tableRow;
          return isBandedOrHeaderRow(tableRow);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref4) {
          var tableColumns = _ref4.tableColumns,
              tableHeaderRows = _ref4.tableHeaderRows,
              tableHeaderColumnChains = _ref4.tableHeaderColumnChains;
          var bandComponent = getBandComponent(params, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains);

          switch (bandComponent.type) {
            case BAND_DUPLICATE_RENDER:
              return createElement(TemplatePlaceholder, null);

            case BAND_EMPTY_CELL:
              return createElement(InvisibleCell, null);

            case BAND_GROUP_CELL:
              {
                var _bandComponent$payloa = bandComponent.payload,
                    value = _bandComponent$payloa.value,
                    payload = _objectWithoutProperties(_bandComponent$payloa, ["value"]);

                return createElement(Cell, _extends({}, params, payload), value);
              }

            case BAND_HEADER_CELL:
              return createElement(TemplatePlaceholder, {
                name: "tableCell",
                params: _objectSpread({}, params, bandComponent.payload)
              });

            default:
              return null;
          }
        });
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref5) {
          var tableRow = _ref5.tableRow,
              tableColumn = _ref5.tableColumn;
          return isHeadingTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(HeaderCell, _extends({
          component: CellPlaceholder$1
        }, params));
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref6) {
          var tableRow = _ref6.tableRow;
          return isBandedTableRow(tableRow);
        }
      }, function (params) {
        return createElement(Row, params);
      }));
    }
  }]);

  return TableBandHeader;
}(PureComponent);
TableBandHeader.ROW_TYPE = TABLE_BAND_TYPE;
process.env.NODE_ENV !== "production" ? TableBandHeader.propTypes = {
  columnBands: array.isRequired,
  cellComponent: func.isRequired,
  rowComponent: func.isRequired,
  bandedHeaderCellComponent: func.isRequired,
  invisibleCellComponent: func.isRequired
} : void 0;
TableBandHeader.components = {
  cellComponent: 'Cell',
  rowComponent: 'Row',
  bandedHeaderCellComponent: 'BandedHeaderCell',
  invisibleCellComponent: 'InvisibleCell'
};

var pluginDependencies$b = [{
  name: 'FilteringState'
}, {
  name: 'Table'
}, {
  name: 'DataTypeProvider',
  optional: true
}];
var defaultMessages$1 = {
  filterPlaceholder: 'Filter...',
  contains: 'Contains',
  notContains: 'Does not contain',
  startsWith: 'Starts with',
  endsWith: 'Ends with',
  equal: 'Equals',
  notEqual: 'Does not equal',
  greaterThan: 'Greater than',
  greaterThanOrEqual: 'Greater than or equal to',
  lessThan: 'Less than',
  lessThanOrEqual: 'Less than or equal to'
};
var TableFilterRow =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableFilterRow, _React$PureComponent);

  function TableFilterRow(props) {
    var _this;

    _classCallCheck(this, TableFilterRow);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TableFilterRow).call(this, props));
    _this.state = {
      filterOperations: {}
    };
    return _this;
  }

  _createClass(TableFilterRow, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          rowHeight = _this$props.rowHeight,
          showFilterSelector = _this$props.showFilterSelector,
          FilterCell = _this$props.cellComponent,
          FilterRow = _this$props.rowComponent,
          FilterSelector = _this$props.filterSelectorComponent,
          iconComponent = _this$props.iconComponent,
          toggleButtonComponent = _this$props.toggleButtonComponent,
          EditorComponent = _this$props.editorComponent,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(_objectSpread({}, defaultMessages$1, messages));

      var tableHeaderRowsComputed = function tableHeaderRowsComputed(_ref) {
        var tableHeaderRows = _ref.tableHeaderRows;
        return tableHeaderRowsWithFilter(tableHeaderRows, rowHeight);
      };

      return createElement(Plugin, {
        name: "TableFilterRow",
        dependencies: pluginDependencies$b
      }, createElement(Getter, {
        name: "tableHeaderRows",
        computed: tableHeaderRowsComputed
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref2) {
          var tableRow = _ref2.tableRow,
              tableColumn = _ref2.tableColumn;
          return isFilterTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref3, _ref4) {
          var filters = _ref3.filters,
              isColumnFilteringEnabled = _ref3.isColumnFilteringEnabled,
              getAvailableFilterOperations = _ref3.getAvailableFilterOperations;
          var changeColumnFilter$$1 = _ref4.changeColumnFilter;
          var filterOperations = _this2.state.filterOperations;
          var columnName = params.tableColumn.column.name;
          var filter = getColumnFilterConfig(filters, columnName);

          var onFilter = function onFilter(config) {
            return changeColumnFilter$$1({
              columnName: columnName,
              config: config
            });
          };

          var columnFilterOperations = getColumnFilterOperations(getAvailableFilterOperations, columnName);
          var selectedFilterOperation = getSelectedFilterOperation(filterOperations, columnName, filter, columnFilterOperations);

          var handleFilterOperationChange = function handleFilterOperationChange(value) {
            _this2.setState({
              filterOperations: _objectSpread({}, filterOperations, _defineProperty({}, columnName, value))
            });

            if (filter && !isFilterValueEmpty(filter.value)) {
              onFilter({
                value: filter.value,
                operation: value
              });
            }
          };

          var handleFilterValueChange = function handleFilterValueChange(value) {
            return onFilter(!isFilterValueEmpty(value) ? {
              value: value,
              operation: selectedFilterOperation
            } : null);
          };

          var filteringEnabled = isColumnFilteringEnabled(columnName);
          return createElement(TemplatePlaceholder, {
            name: "valueEditor",
            params: {
              column: params.tableColumn.column,
              value: filter ? filter.value : undefined,
              onValueChange: handleFilterValueChange
            }
          }, function (content) {
            return createElement(FilterCell, _extends({}, params, {
              getMessage: getMessage,
              column: params.tableColumn.column,
              filter: filter,
              filteringEnabled: filteringEnabled,
              onFilter: onFilter
            }), showFilterSelector ? createElement(FilterSelector, {
              toggleButtonComponent: toggleButtonComponent,
              iconComponent: iconComponent,
              value: selectedFilterOperation,
              availableValues: columnFilterOperations,
              onChange: handleFilterOperationChange,
              disabled: !filteringEnabled,
              getMessage: getMessage
            }) : null, content || createElement(EditorComponent, {
              value: filter ? filter.value : undefined,
              disabled: !filteringEnabled,
              getMessage: getMessage,
              onChange: handleFilterValueChange
            }));
          });
        });
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref5) {
          var tableRow = _ref5.tableRow;
          return isFilterTableRow(tableRow);
        }
      }, function (params) {
        return createElement(FilterRow, params);
      }));
    }
  }]);

  return TableFilterRow;
}(PureComponent);
TableFilterRow.ROW_TYPE = TABLE_FILTER_TYPE;
process.env.NODE_ENV !== "production" ? TableFilterRow.propTypes = {
  rowHeight: any,
  showFilterSelector: bool,
  messages: shape({
    filterPlaceholder: string,
    contains: string,
    notContains: string,
    startsWith: string,
    endsWith: string,
    equal: string,
    notEqual: string,
    greaterThan: string,
    greaterThanOrEqual: string,
    lessThan: string,
    lessThanOrEqual: string
  }),
  cellComponent: func.isRequired,
  rowComponent: func.isRequired,
  filterSelectorComponent: func.isRequired,
  toggleButtonComponent: func.isRequired,
  iconComponent: func.isRequired,
  editorComponent: func.isRequired
} : void 0;
TableFilterRow.defaultProps = {
  rowHeight: undefined,
  showFilterSelector: false,
  messages: {}
};
TableFilterRow.components = {
  rowComponent: 'Row',
  cellComponent: 'Cell',
  filterSelectorComponent: 'FilterSelector',
  iconComponent: 'Icon',
  editorComponent: 'Editor',
  toggleButtonComponent: 'ToggleButton'
};

var pluginDependencies$c = [{
  name: 'EditingState'
}, {
  name: 'Table'
}, {
  name: 'DataTypeProvider',
  optional: true
}];
var TableEditRow =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableEditRow, _React$PureComponent);

  function TableEditRow() {
    _classCallCheck(this, TableEditRow);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableEditRow).apply(this, arguments));
  }

  _createClass(TableEditRow, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          EditCell = _this$props.cellComponent,
          EditRow = _this$props.rowComponent,
          rowHeight = _this$props.rowHeight;

      var tableBodyRowsComputed = function tableBodyRowsComputed(_ref) {
        var tableBodyRows = _ref.tableBodyRows,
            editingRowIds = _ref.editingRowIds,
            addedRows = _ref.addedRows;
        return tableRowsWithEditing(tableBodyRows, editingRowIds, addedRows, rowHeight);
      };

      return createElement(Plugin, {
        name: "TableEditRow",
        dependencies: pluginDependencies$c
      }, createElement(Getter, {
        name: "tableBodyRows",
        computed: tableBodyRowsComputed
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref2) {
          var tableRow = _ref2.tableRow,
              tableColumn = _ref2.tableColumn;
          return isEditTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref3, _ref4) {
          var getCellValue = _ref3.getCellValue,
              createRowChange = _ref3.createRowChange,
              rowChanges = _ref3.rowChanges,
              isColumnEditingEnabled = _ref3.isColumnEditingEnabled;
          var changeAddedRow$$1 = _ref4.changeAddedRow,
              changeRow$$1 = _ref4.changeRow;
          var _params$tableRow = params.tableRow,
              rowId = _params$tableRow.rowId,
              row = _params$tableRow.row;
          var column = params.tableColumn.column;
          var columnName = column.name;
          var isNew = isAddedTableRow(params.tableRow);
          var changedRow = isNew ? row : _objectSpread({}, row, getRowChange(rowChanges, rowId));
          var value = getCellValue(changedRow, columnName);

          var onValueChange = function onValueChange(newValue) {
            var changeArgs = {
              rowId: rowId,
              change: createRowChange(changedRow, newValue, columnName)
            };

            if (isNew) {
              changeAddedRow$$1(changeArgs);
            } else {
              changeRow$$1(changeArgs);
            }
          };

          return createElement(TemplatePlaceholder, {
            name: "valueEditor",
            params: {
              column: column,
              row: row,
              value: value,
              onValueChange: onValueChange
            }
          }, function (content) {
            return createElement(EditCell, _extends({}, params, {
              row: row,
              column: column,
              value: value,
              editingEnabled: isColumnEditingEnabled(columnName),
              onValueChange: onValueChange
            }), content);
          });
        });
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref5) {
          var tableRow = _ref5.tableRow;
          return isEditTableRow(tableRow) || isAddedTableRow(tableRow);
        }
      }, function (params) {
        return createElement(EditRow, _extends({}, params, {
          row: params.tableRow.row
        }));
      }));
    }
  }]);

  return TableEditRow;
}(PureComponent);
TableEditRow.ADDED_ROW_TYPE = TABLE_ADDED_TYPE;
TableEditRow.EDIT_ROW_TYPE = TABLE_EDIT_TYPE;
process.env.NODE_ENV !== "production" ? TableEditRow.propTypes = {
  rowHeight: any,
  cellComponent: func.isRequired,
  rowComponent: func.isRequired
} : void 0;
TableEditRow.defaultProps = {
  rowHeight: undefined
};
TableEditRow.components = {
  rowComponent: 'Row',
  cellComponent: 'Cell'
};

var pluginDependencies$d = [{
  name: 'EditingState'
}, {
  name: 'Table'
}];
var defaultMessages$2 = {
  addCommand: 'New',
  editCommand: 'Edit',
  deleteCommand: 'Delete',
  commitCommand: 'Save',
  cancelCommand: 'Cancel'
};
var TableEditColumn =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableEditColumn, _React$PureComponent);

  function TableEditColumn() {
    _classCallCheck(this, TableEditColumn);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableEditColumn).apply(this, arguments));
  }

  _createClass(TableEditColumn, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          Cell = _this$props.cellComponent,
          HeaderCell = _this$props.headerCellComponent,
          Command = _this$props.commandComponent,
          showAddCommand = _this$props.showAddCommand,
          showEditCommand = _this$props.showEditCommand,
          showDeleteCommand = _this$props.showDeleteCommand,
          width = _this$props.width,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(_objectSpread({}, defaultMessages$2, messages));

      var tableColumnsComputed = function tableColumnsComputed(_ref) {
        var tableColumns = _ref.tableColumns;
        return tableColumnsWithEditing(tableColumns, width);
      };

      return createElement(Plugin, {
        name: "TableEditColumn",
        dependencies: pluginDependencies$d
      }, createElement(Getter, {
        name: "tableColumns",
        computed: tableColumnsComputed
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref2) {
          var tableRow = _ref2.tableRow,
              tableColumn = _ref2.tableColumn;
          return isHeadingEditCommandsTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (getters, actions) {
          return createElement(HeaderCell, params, showAddCommand && createElement(Command, {
            id: "add",
            text: getMessage('addCommand'),
            onExecute: function onExecute() {
              return actions.addRow();
            }
          }));
        });
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref3) {
          var tableRow = _ref3.tableRow,
              tableColumn = _ref3.tableColumn;
          return isEditCommandsTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (getters, actions) {
          var isEdit = isEditTableRow(params.tableRow);
          var isNew = isAddedTableRow(params.tableRow);
          var isEditing = isEdit || isNew;
          var rowIds = [params.tableRow.rowId];
          return createElement(Cell, _extends({}, params, {
            row: params.tableRow.row
          }), showEditCommand && !isEditing && createElement(Command, {
            id: "edit",
            text: getMessage('editCommand'),
            onExecute: function onExecute() {
              return actions.startEditRows({
                rowIds: rowIds
              });
            }
          }), showDeleteCommand && !isEditing && createElement(Command, {
            id: "delete",
            text: getMessage('deleteCommand'),
            onExecute: function onExecute() {
              actions.deleteRows({
                rowIds: rowIds
              });
              actions.commitDeletedRows({
                rowIds: rowIds
              });
            }
          }), isEditing && createElement(Command, {
            id: "commit",
            text: getMessage('commitCommand'),
            onExecute: function onExecute() {
              if (isNew) {
                actions.commitAddedRows({
                  rowIds: rowIds
                });
              } else {
                actions.stopEditRows({
                  rowIds: rowIds
                });
                actions.commitChangedRows({
                  rowIds: rowIds
                });
              }
            }
          }), isEditing && createElement(Command, {
            id: "cancel",
            text: getMessage('cancelCommand'),
            onExecute: function onExecute() {
              if (isNew) {
                actions.cancelAddedRows({
                  rowIds: rowIds
                });
              } else {
                actions.stopEditRows({
                  rowIds: rowIds
                });
                actions.cancelChangedRows({
                  rowIds: rowIds
                });
              }
            }
          }));
        });
      }));
    }
  }]);

  return TableEditColumn;
}(PureComponent);
TableEditColumn.COLUMN_TYPE = TABLE_EDIT_COMMAND_TYPE;
process.env.NODE_ENV !== "production" ? TableEditColumn.propTypes = {
  cellComponent: func.isRequired,
  headerCellComponent: func.isRequired,
  commandComponent: func.isRequired,
  showAddCommand: bool,
  showEditCommand: bool,
  showDeleteCommand: bool,
  width: number,
  messages: shape({
    addCommand: string,
    editCommand: string,
    deleteCommand: string,
    commitCommand: string,
    cancelCommand: string
  })
} : void 0;
TableEditColumn.defaultProps = {
  showAddCommand: false,
  showEditCommand: false,
  showDeleteCommand: false,
  width: 140,
  messages: {}
};
TableEditColumn.components = {
  cellComponent: 'Cell',
  headerCellComponent: 'HeaderCell',
  commandComponent: 'Command'
};

var pluginDependencies$e = [{
  name: 'Table'
}];
var TableColumnResizing =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableColumnResizing, _React$PureComponent);

  function TableColumnResizing(props) {
    var _this;

    _classCallCheck(this, TableColumnResizing);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TableColumnResizing).call(this, props));
    _this.state = {
      columnWidths: props.columnWidths || props.defaultColumnWidths,
      draftColumnWidths: []
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      columnWidths: function columnWidths() {
        var onColumnWidthsChange = _this.props.onColumnWidthsChange;
        return onColumnWidthsChange;
      }
    });
    _this.tableColumnsComputed = memoize(function (columnWidths) {
      return function (_ref) {
        var tableColumns = _ref.tableColumns;
        return tableColumnsWithWidths(tableColumns, columnWidths);
      };
    });
    _this.tableColumnsDraftComputed = memoize(function (draftColumnWidths) {
      return function (_ref2) {
        var tableColumns = _ref2.tableColumns;
        return tableColumnsWithDraftWidths(tableColumns, draftColumnWidths);
      };
    });
    _this.changeTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {
      var minColumnWidth = _this.props.minColumnWidth;
      return changeTableColumnWidth(prevState, _objectSpread({}, payload, {
        minColumnWidth: minColumnWidth
      }));
    });
    _this.draftTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {
      var minColumnWidth = _this.props.minColumnWidth;
      return draftTableColumnWidth(prevState, _objectSpread({}, payload, {
        minColumnWidth: minColumnWidth
      }));
    });
    _this.cancelTableColumnWidthDraft = stateHelper.applyReducer.bind(stateHelper, cancelTableColumnWidthDraft);
    return _this;
  }

  _createClass(TableColumnResizing, [{
    key: "render",
    value: function render() {
      var _this$state = this.state,
          columnWidths = _this$state.columnWidths,
          draftColumnWidths = _this$state.draftColumnWidths;
      var tableColumnsComputed = this.tableColumnsComputed(columnWidths);
      var tableColumnsDraftComputed = this.tableColumnsDraftComputed(draftColumnWidths);
      return createElement(Plugin, {
        name: "TableColumnResizing",
        dependencies: pluginDependencies$e
      }, createElement(Getter, {
        name: "tableColumnResizingEnabled",
        value: true
      }), createElement(Getter, {
        name: "tableColumns",
        computed: tableColumnsComputed
      }), createElement(Getter, {
        name: "tableColumns",
        computed: tableColumnsDraftComputed
      }), createElement(Action, {
        name: "changeTableColumnWidth",
        action: this.changeTableColumnWidth
      }), createElement(Action, {
        name: "draftTableColumnWidth",
        action: this.draftTableColumnWidth
      }), createElement(Action, {
        name: "cancelTableColumnWidthDraft",
        action: this.cancelTableColumnWidthDraft
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$columnWidt = nextProps.columnWidths,
          columnWidths = _nextProps$columnWidt === void 0 ? prevState.columnWidths : _nextProps$columnWidt;
      return {
        columnWidths: columnWidths
      };
    }
  }]);

  return TableColumnResizing;
}(PureComponent);
process.env.NODE_ENV !== "production" ? TableColumnResizing.propTypes = {
  defaultColumnWidths: array,
  columnWidths: array,
  onColumnWidthsChange: func,
  minColumnWidth: number.isRequired
} : void 0;
TableColumnResizing.defaultProps = {
  defaultColumnWidths: [],
  columnWidths: undefined,
  onColumnWidthsChange: undefined
};

var pluginDependencies$f = [{
  name: 'PagingState'
}];
var defaultMessages$3 = {
  showAll: 'All',
  info: function info(_ref) {
    var from = _ref.from,
        to = _ref.to,
        count = _ref.count;
    return "".concat(from).concat(from < to ? "-".concat(to) : '', " of ").concat(count);
  }
};
var PagingPanel =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(PagingPanel, _React$PureComponent);

  function PagingPanel() {
    _classCallCheck(this, PagingPanel);

    return _possibleConstructorReturn(this, _getPrototypeOf(PagingPanel).apply(this, arguments));
  }

  _createClass(PagingPanel, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          Pager = _this$props.containerComponent,
          pageSizes = _this$props.pageSizes,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(_objectSpread({}, defaultMessages$3, messages));
      return createElement(Plugin, {
        name: "PagingPanel",
        dependencies: pluginDependencies$f
      }, createElement(Template, {
        name: "footer"
      }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_ref2, _ref3) {
        var currentPage$$1 = _ref2.currentPage,
            pageSize = _ref2.pageSize,
            totalCount = _ref2.totalCount;
        var setCurrentPage$$1 = _ref3.setCurrentPage,
            setPageSize$$1 = _ref3.setPageSize;
        return createElement(Pager, {
          currentPage: currentPage$$1,
          pageSize: pageSize,
          totalCount: totalCount,
          totalPages: pageCount(totalCount, pageSize),
          pageSizes: pageSizes,
          getMessage: getMessage,
          onCurrentPageChange: setCurrentPage$$1,
          onPageSizeChange: setPageSize$$1
        });
      })));
    }
  }]);

  return PagingPanel;
}(PureComponent);
process.env.NODE_ENV !== "production" ? PagingPanel.propTypes = {
  pageSizes: arrayOf(number),
  containerComponent: func.isRequired,
  messages: shape({
    showAll: string,
    info: oneOfType([string, func])
  })
} : void 0;
PagingPanel.defaultProps = {
  pageSizes: [],
  messages: {}
};
PagingPanel.components = {
  containerComponent: 'Container'
};

var ItemLayout =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(ItemLayout, _React$PureComponent);

  function ItemLayout(props) {
    var _this;

    _classCallCheck(this, ItemLayout);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ItemLayout).call(this, props));
    _this.state = {
      dragging: false
    };
    return _this;
  }

  _createClass(ItemLayout, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          item = _this$props.item,
          Item = _this$props.itemComponent,
          draggingEnabled = _this$props.draggingEnabled,
          onDragStart = _this$props.onDragStart,
          onDragEnd = _this$props.onDragEnd;
      var dragging = this.state.dragging;
      var itemElement = createElement(Item, {
        item: _objectSpread({}, item, {
          draft: dragging || item.draft
        })
      });
      return draggingEnabled ? createElement(DragSource, {
        payload: [{
          type: 'column',
          columnName: item.column.name
        }],
        onStart: function onStart() {
          _this2.setState({
            dragging: true
          });

          onDragStart();
        },
        onEnd: function onEnd() {
          _this2.setState({
            dragging: false
          });

          onDragEnd();
        }
      }, itemElement) : itemElement;
    }
  }]);

  return ItemLayout;
}(PureComponent);
process.env.NODE_ENV !== "production" ? ItemLayout.propTypes = {
  item: shape({
    column: object,
    draft: bool
  }).isRequired,
  itemComponent: func.isRequired,
  draggingEnabled: bool,
  onDragStart: func,
  onDragEnd: func
} : void 0;
ItemLayout.defaultProps = {
  draggingEnabled: false,
  onDragStart: function onDragStart() {},
  onDragEnd: function onDragEnd() {}
};

var GroupPanelLayout =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(GroupPanelLayout, _React$PureComponent);

  function GroupPanelLayout(props) {
    var _this;

    _classCallCheck(this, GroupPanelLayout);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GroupPanelLayout).call(this, props));
    _this.state = {
      sourceColumnName: null,
      targetItemIndex: -1
    };

    _this.handleDragEvent = function (eventHandler, _ref) {
      var payload = _ref.payload,
          restArgs = _objectWithoutProperties(_ref, ["payload"]);

      var isColumnGroupingEnabled = _this.props.isColumnGroupingEnabled;
      var columnName = payload[0].columnName;

      if (isColumnGroupingEnabled(columnName)) {
        eventHandler(_objectSpread({
          payload: payload
        }, restArgs));
      }
    };

    _this.onEnter = function (_ref2) {
      var payload = _ref2.payload;

      _this.setState({
        sourceColumnName: payload[0].columnName
      });
    };

    _this.onOver = function (_ref3) {
      var clientOffset = _ref3.clientOffset;
      var _this$props = _this.props,
          onGroupDraft = _this$props.onGroupDraft,
          items = _this$props.items;
      var _this$state = _this.state,
          sourceColumnName = _this$state.sourceColumnName,
          prevTargetItemIndex = _this$state.targetItemIndex; // eslint-disable-next-line react/no-find-dom-node

      var itemGeometries = _this.itemRefs.map(function (ref) {
        return findDOMNode(ref).getBoundingClientRect();
      });

      var sourceItemIndex = items.findIndex(function (_ref4) {
        var column = _ref4.column;
        return column.name === sourceColumnName;
      });
      var targetItemIndex = getGroupCellTargetIndex(itemGeometries, sourceItemIndex, clientOffset);
      if (prevTargetItemIndex === targetItemIndex) return;
      onGroupDraft({
        columnName: sourceColumnName,
        groupIndex: targetItemIndex
      });

      _this.setState({
        targetItemIndex: targetItemIndex
      });
    };

    _this.onLeave = function () {
      var onGroupDraft = _this.props.onGroupDraft;
      var sourceColumnName = _this.state.sourceColumnName;

      if (!_this.draggingColumnName) {
        _this.resetState();

        return;
      }

      onGroupDraft({
        columnName: sourceColumnName,
        groupIndex: -1
      });

      _this.setState({
        targetItemIndex: -1
      });
    };

    _this.onDrop = function () {
      var onGroup = _this.props.onGroup;
      var _this$state2 = _this.state,
          sourceColumnName = _this$state2.sourceColumnName,
          targetItemIndex = _this$state2.targetItemIndex;

      _this.resetState();

      onGroup({
        columnName: sourceColumnName,
        groupIndex: targetItemIndex
      });
    };

    _this.onDragStart = function (columnName) {
      _this.draggingColumnName = columnName;
    };

    _this.onDragEnd = function () {
      _this.draggingColumnName = null;
      var _this$state3 = _this.state,
          sourceColumnName = _this$state3.sourceColumnName,
          targetItemIndex = _this$state3.targetItemIndex;
      var onGroup = _this.props.onGroup;

      if (sourceColumnName && targetItemIndex === -1) {
        onGroup({
          columnName: sourceColumnName
        });
      }

      _this.resetState();
    };

    return _this;
  }

  _createClass(GroupPanelLayout, [{
    key: "resetState",
    value: function resetState() {
      var onGroupDraftCancel = this.props.onGroupDraftCancel;
      onGroupDraftCancel();
      this.setState({
        sourceColumnName: null,
        targetItemIndex: -1
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          items = _this$props2.items,
          EmptyMessage = _this$props2.emptyMessageComponent,
          Container = _this$props2.containerComponent,
          Item = _this$props2.itemComponent,
          draggingEnabled = _this$props2.draggingEnabled,
          isColumnGroupingEnabled = _this$props2.isColumnGroupingEnabled;
      this.itemRefs = [];
      var groupPanel = items.length ? createElement(Container, null, items.map(function (item) {
        var columnName = item.column.name;
        return createElement(ItemLayout, {
          key: columnName,
          ref: function ref(element) {
            return element && _this2.itemRefs.push(element);
          },
          item: item,
          itemComponent: Item,
          draggingEnabled: draggingEnabled && isColumnGroupingEnabled(columnName),
          onDragStart: function onDragStart() {
            return _this2.onDragStart(columnName);
          },
          onDragEnd: _this2.onDragEnd
        });
      })) : createElement(EmptyMessage, null);
      return draggingEnabled ? createElement(DropTarget, {
        onEnter: function onEnter(args) {
          return _this2.handleDragEvent(_this2.onEnter, args);
        },
        onOver: function onOver(args) {
          return _this2.handleDragEvent(_this2.onOver, args);
        },
        onLeave: function onLeave(args) {
          return _this2.handleDragEvent(_this2.onLeave, args);
        },
        onDrop: function onDrop(args) {
          return _this2.handleDragEvent(_this2.onDrop, args);
        }
      }, groupPanel) : groupPanel;
    }
  }]);

  return GroupPanelLayout;
}(PureComponent);
process.env.NODE_ENV !== "production" ? GroupPanelLayout.propTypes = {
  items: arrayOf(shape({
    column: object,
    draft: bool
  })).isRequired,
  onGroup: func,
  itemComponent: func.isRequired,
  containerComponent: func.isRequired,
  emptyMessageComponent: func.isRequired,
  draggingEnabled: bool,
  isColumnGroupingEnabled: func,
  onGroupDraft: func,
  onGroupDraftCancel: func
} : void 0;
GroupPanelLayout.defaultProps = {
  onGroup: function onGroup() {},
  draggingEnabled: false,
  isColumnGroupingEnabled: function isColumnGroupingEnabled() {},
  onGroupDraft: function onGroupDraft() {},
  onGroupDraftCancel: function onGroupDraftCancel() {}
};

var defaultMessages$4 = {
  groupByColumn: 'Drag a column header here to group by that column'
};

var GroupingPanelRaw =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(GroupingPanelRaw, _React$PureComponent);

  function GroupingPanelRaw() {
    _classCallCheck(this, GroupingPanelRaw);

    return _possibleConstructorReturn(this, _getPrototypeOf(GroupingPanelRaw).apply(this, arguments));
  }

  _createClass(GroupingPanelRaw, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          LayoutComponent = _this$props.layoutComponent,
          Container = _this$props.containerComponent,
          Item = _this$props.itemComponent,
          EmptyMessage = _this$props.emptyMessageComponent,
          showSortingControls = _this$props.showSortingControls,
          showGroupingControls = _this$props.showGroupingControls,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(_objectSpread({}, defaultMessages$4, messages));

      var EmptyMessagePlaceholder = function EmptyMessagePlaceholder() {
        return createElement(EmptyMessage, {
          getMessage: getMessage
        });
      };

      var ItemPlaceholder = function ItemPlaceholder(_ref) {
        var item = _ref.item;
        var columnName = item.column.name;
        return createElement(TemplateConnector, null, function (_ref2, _ref3) {
          var sorting = _ref2.sorting,
              isColumnSortingEnabled = _ref2.isColumnSortingEnabled,
              isColumnGroupingEnabled = _ref2.isColumnGroupingEnabled;
          var changeColumnGrouping$$1 = _ref3.changeColumnGrouping,
              changeColumnSorting$$1 = _ref3.changeColumnSorting;
          var sortingEnabled = isColumnSortingEnabled && isColumnSortingEnabled(columnName);
          var groupingEnabled = isColumnGroupingEnabled && isColumnGroupingEnabled(columnName);
          return createElement(Item, {
            item: item,
            sortingEnabled: sortingEnabled,
            groupingEnabled: groupingEnabled,
            showSortingControls: showSortingControls,
            sortingDirection: showSortingControls ? getColumnSortingDirection(sorting, columnName) : undefined,
            showGroupingControls: showGroupingControls,
            onGroup: function onGroup() {
              return changeColumnGrouping$$1({
                columnName: columnName
              });
            },
            onSort: function onSort(_ref4) {
              var direction = _ref4.direction,
                  keepOther = _ref4.keepOther;
              return changeColumnSorting$$1({
                columnName: columnName,
                direction: direction,
                keepOther: keepOther
              });
            }
          });
        });
      };

      return createElement(Plugin, {
        name: "GroupingPanel",
        dependencies: [{
          name: 'GroupingState'
        }, {
          name: 'Toolbar'
        }, {
          name: 'SortingState',
          optional: !showSortingControls
        }]
      }, createElement(Template, {
        name: "toolbarContent"
      }, createElement(TemplateConnector, null, function (_ref5, _ref6) {
        var columns = _ref5.columns,
            grouping = _ref5.grouping,
            draftGrouping = _ref5.draftGrouping,
            draggingEnabled = _ref5.draggingEnabled,
            isColumnGroupingEnabled = _ref5.isColumnGroupingEnabled;
        var changeColumnGrouping$$1 = _ref6.changeColumnGrouping,
            draftColumnGrouping$$1 = _ref6.draftColumnGrouping,
            cancelColumnGroupingDraft$$1 = _ref6.cancelColumnGroupingDraft;
        return createElement(LayoutComponent, {
          items: groupingPanelItems(columns, grouping, draftGrouping),
          isColumnGroupingEnabled: isColumnGroupingEnabled,
          draggingEnabled: draggingEnabled,
          onGroup: changeColumnGrouping$$1,
          onGroupDraft: draftColumnGrouping$$1,
          onGroupDraftCancel: cancelColumnGroupingDraft$$1,
          itemComponent: ItemPlaceholder,
          emptyMessageComponent: EmptyMessagePlaceholder,
          containerComponent: Container
        });
      }), createElement(TemplatePlaceholder, null)));
    }
  }]);

  return GroupingPanelRaw;
}(PureComponent);

process.env.NODE_ENV !== "production" ? GroupingPanelRaw.propTypes = {
  showSortingControls: bool,
  showGroupingControls: bool,
  layoutComponent: func.isRequired,
  containerComponent: func.isRequired,
  itemComponent: func.isRequired,
  emptyMessageComponent: func.isRequired,
  messages: object
} : void 0;
GroupingPanelRaw.defaultProps = {
  showSortingControls: false,
  showGroupingControls: false,
  messages: {}
};
GroupingPanelRaw.components = {
  layoutComponent: 'Layout',
  containerComponent: 'Container',
  itemComponent: 'Item',
  emptyMessageComponent: 'EmptyMessage'
};
var GroupingPanel = withComponents({
  Layout: GroupPanelLayout
})(GroupingPanelRaw);

var DataTypeProvider =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(DataTypeProvider, _React$PureComponent);

  function DataTypeProvider() {
    _classCallCheck(this, DataTypeProvider);

    return _possibleConstructorReturn(this, _getPrototypeOf(DataTypeProvider).apply(this, arguments));
  }

  _createClass(DataTypeProvider, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          columnNames = _this$props.for,
          Formatter = _this$props.formatterComponent,
          Editor = _this$props.editorComponent,
          availableFilterOperations = _this$props.availableFilterOperations;

      var getAvailableFilterOperationsComputed = function getAvailableFilterOperationsComputed(_ref) {
        var getAvailableFilterOperations = _ref.getAvailableFilterOperations;
        return getAvailableFilterOperationsGetter(getAvailableFilterOperations, availableFilterOperations, columnNames);
      };

      return createElement(Plugin, {
        name: "DataTypeProvider"
      }, createElement(Getter, {
        name: "getAvailableFilterOperations",
        computed: getAvailableFilterOperationsComputed
      }), Formatter ? createElement(Template, {
        name: "valueFormatter",
        predicate: function predicate(_ref2) {
          var column = _ref2.column;
          return columnNames.includes(column.name);
        }
      }, function (params) {
        return createElement(Formatter, params);
      }) : null, Editor ? createElement(Template, {
        name: "valueEditor",
        predicate: function predicate(_ref3) {
          var column = _ref3.column;
          return columnNames.includes(column.name);
        }
      }, function (params) {
        return createElement(Editor, params);
      }) : null);
    }
  }]);

  return DataTypeProvider;
}(PureComponent);
process.env.NODE_ENV !== "production" ? DataTypeProvider.propTypes = {
  for: arrayOf(string).isRequired,
  formatterComponent: func,
  editorComponent: func,
  availableFilterOperations: arrayOf(string)
} : void 0;
DataTypeProvider.defaultProps = {
  formatterComponent: undefined,
  editorComponent: undefined,
  availableFilterOperations: undefined
};

var pluginDependencies$g = [{
  name: 'Table'
}];
var defaultMessages$5 = {
  noColumns: 'Nothing to show'
};

var visibleTableColumnsComputed = function visibleTableColumnsComputed(_ref) {
  var tableColumns = _ref.tableColumns,
      hiddenColumnNames = _ref.hiddenColumnNames;
  return visibleTableColumns(tableColumns, hiddenColumnNames);
};

var columnExtensionValueGetter$4 = function columnExtensionValueGetter(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, 'togglingEnabled', defaultValue);
};

var TableColumnVisibility =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableColumnVisibility, _React$PureComponent);

  function TableColumnVisibility(props) {
    var _this;

    _classCallCheck(this, TableColumnVisibility);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TableColumnVisibility).call(this, props));
    _this.state = {
      hiddenColumnNames: props.hiddenColumnNames || props.defaultHiddenColumnNames
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      hiddenColumnNames: function hiddenColumnNames() {
        var onHiddenColumnNamesChange = _this.props.onHiddenColumnNamesChange;
        return onHiddenColumnNamesChange;
      }
    });
    _this.toggleColumnVisibility = stateHelper.applyFieldReducer.bind(stateHelper, 'hiddenColumnNames', toggleColumn);
    return _this;
  }

  _createClass(TableColumnVisibility, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          EmptyMessage = _this$props.emptyMessageComponent,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(_objectSpread({}, defaultMessages$5, messages));
      var hiddenColumnNames = this.state.hiddenColumnNames;
      var _this$props2 = this.props,
          columnExtensions = _this$props2.columnExtensions,
          columnTogglingEnabled = _this$props2.columnTogglingEnabled;
      return createElement(Plugin, {
        name: "TableColumnVisibility",
        dependencies: pluginDependencies$g
      }, createElement(Getter, {
        name: "hiddenColumnNames",
        value: hiddenColumnNames
      }), createElement(Getter, {
        name: "tableColumns",
        computed: visibleTableColumnsComputed
      }), createElement(Getter, {
        name: "isColumnTogglingEnabled",
        value: columnExtensionValueGetter$4(columnExtensions, columnTogglingEnabled)
      }), createElement(Action, {
        name: "toggleColumnVisibility",
        action: this.toggleColumnVisibility
      }), createElement(Template, {
        name: "table"
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref2) {
          var tableColumns = _ref2.tableColumns;
          return tableDataColumnsExist(tableColumns) ? createElement(TemplatePlaceholder, null) : createElement(EmptyMessage, _extends({
            getMessage: getMessage
          }, params));
        });
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$hiddenColu = nextProps.hiddenColumnNames,
          hiddenColumnNames = _nextProps$hiddenColu === void 0 ? prevState.hiddenColumnNames : _nextProps$hiddenColu;
      return {
        hiddenColumnNames: hiddenColumnNames
      };
    }
  }]);

  return TableColumnVisibility;
}(PureComponent);
process.env.NODE_ENV !== "production" ? TableColumnVisibility.propTypes = {
  hiddenColumnNames: arrayOf(string),
  defaultHiddenColumnNames: arrayOf(string),
  emptyMessageComponent: func.isRequired,
  onHiddenColumnNamesChange: func,
  messages: object,
  columnExtensions: array,
  columnTogglingEnabled: bool
} : void 0;
TableColumnVisibility.defaultProps = {
  hiddenColumnNames: undefined,
  defaultHiddenColumnNames: [],
  onHiddenColumnNamesChange: undefined,
  messages: {},
  columnExtensions: undefined,
  columnTogglingEnabled: true
};
TableColumnVisibility.components = {
  emptyMessageComponent: 'EmptyMessage'
};

var Toolbar =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(Toolbar, _React$PureComponent);

  function Toolbar() {
    _classCallCheck(this, Toolbar);

    return _possibleConstructorReturn(this, _getPrototypeOf(Toolbar).apply(this, arguments));
  }

  _createClass(Toolbar, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          Root = _this$props.rootComponent,
          FlexibleSpaceComponent = _this$props.flexibleSpaceComponent;
      return createElement(Plugin, {
        name: "Toolbar"
      }, createElement(Template, {
        name: "header"
      }, createElement(Root, null, createElement(TemplatePlaceholder, {
        name: "toolbarContent"
      })), createElement(TemplatePlaceholder, null)), createElement(Template, {
        name: "toolbarContent"
      }, createElement(FlexibleSpaceComponent, null)));
    }
  }]);

  return Toolbar;
}(PureComponent);
process.env.NODE_ENV !== "production" ? Toolbar.propTypes = {
  rootComponent: func.isRequired,
  flexibleSpaceComponent: func.isRequired
} : void 0;
Toolbar.components = {
  rootComponent: 'Root',
  flexibleSpaceComponent: 'FlexibleSpace'
};

var TreeDataState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TreeDataState, _React$PureComponent);

  function TreeDataState(props) {
    var _this;

    _classCallCheck(this, TreeDataState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TreeDataState).call(this, props));
    _this.state = {
      expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      expandedRowIds: function expandedRowIds() {
        var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;
        return onExpandedRowIdsChange;
      }
    });
    _this.toggleRowExpanded = stateHelper.applyFieldReducer.bind(stateHelper, 'expandedRowIds', toggleRowExpanded);
    return _this;
  }

  _createClass(TreeDataState, [{
    key: "render",
    value: function render() {
      var expandedRowIds = this.state.expandedRowIds;
      return createElement(Plugin, {
        name: "TreeDataState"
      }, createElement(Getter, {
        name: "expandedRowIds",
        value: expandedRowIds
      }), ' ', createElement(Action, {
        name: "toggleRowExpanded",
        action: this.toggleRowExpanded
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$expandedRo = nextProps.expandedRowIds,
          expandedRowIds = _nextProps$expandedRo === void 0 ? prevState.expandedRowIds : _nextProps$expandedRo;
      return {
        expandedRowIds: expandedRowIds
      };
    }
  }]);

  return TreeDataState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? TreeDataState.propTypes = {
  expandedRowIds: array,
  defaultExpandedRowIds: array,
  onExpandedRowIdsChange: func
} : void 0;
TreeDataState.defaultProps = {
  expandedRowIds: undefined,
  defaultExpandedRowIds: [],
  onExpandedRowIdsChange: undefined
};

var pluginDependencies$h = [{
  name: 'TreeDataState'
}];

var expandedTreeRowsComputed = function expandedTreeRowsComputed(_ref) {
  var rows = _ref.rows,
      getRowId = _ref.getRowId,
      expandedRowIds = _ref.expandedRowIds;
  return expandedTreeRows(rows, getRowId, expandedRowIds);
};

var getRowIdComputed$1 = function getRowIdComputed(_ref2) {
  var getRowId = _ref2.getRowId,
      rows = _ref2.rows;
  return customTreeRowIdGetter(getRowId, rows);
};

var getRowLevelKeyComputed = function getRowLevelKeyComputed(_ref3) {
  var getRowLevelKey = _ref3.getRowLevelKey,
      rows = _ref3.rows;
  return customTreeRowLevelKeyGetter(getRowLevelKey, rows);
};

var isTreeRowLeafComputed = function isTreeRowLeafComputed(_ref4) {
  var rows = _ref4.rows;
  return isTreeRowLeafGetter(rows);
};

var getTreeRowLevelComputed = function getTreeRowLevelComputed(_ref5) {
  var rows = _ref5.rows;
  return getTreeRowLevelGetter(rows);
};

var collapsedTreeRowsGetterComputed = function collapsedTreeRowsGetterComputed(_ref6) {
  var rows = _ref6.rows,
      getCollapsedRows = _ref6.getCollapsedRows;
  return collapsedTreeRowsGetter(getCollapsedRows, rows);
};

var unwrappedTreeRowsComputed = function unwrappedTreeRowsComputed(_ref7) {
  var rows = _ref7.rows;
  return unwrappedCustomTreeRows(rows);
};

var CustomTreeData =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(CustomTreeData, _React$PureComponent);

  function CustomTreeData() {
    _classCallCheck(this, CustomTreeData);

    return _possibleConstructorReturn(this, _getPrototypeOf(CustomTreeData).apply(this, arguments));
  }

  _createClass(CustomTreeData, [{
    key: "render",
    value: function render() {
      var getChildRows = this.props.getChildRows;

      var treeRowsComputed = function treeRowsComputed(_ref8) {
        var rows = _ref8.rows;
        return customTreeRowsWithMeta(rows, getChildRows);
      };

      return createElement(Plugin, {
        name: "CustomTreeData",
        dependencies: pluginDependencies$h
      }, createElement(Getter, {
        name: "rows",
        computed: treeRowsComputed
      }), createElement(Getter, {
        name: "getRowId",
        computed: getRowIdComputed$1
      }), createElement(Getter, {
        name: "getRowLevelKey",
        computed: getRowLevelKeyComputed
      }), createElement(Getter, {
        name: "isTreeRowLeaf",
        computed: isTreeRowLeafComputed
      }), createElement(Getter, {
        name: "getTreeRowLevel",
        computed: getTreeRowLevelComputed
      }), createElement(Getter, {
        name: "rows",
        computed: expandedTreeRowsComputed
      }), createElement(Getter, {
        name: "getCollapsedRows",
        computed: collapsedTreeRowsGetterComputed
      }), createElement(Getter, {
        name: "rows",
        computed: unwrappedTreeRowsComputed
      }));
    }
  }]);

  return CustomTreeData;
}(PureComponent);
process.env.NODE_ENV !== "production" ? CustomTreeData.propTypes = {
  getChildRows: func.isRequired
} : void 0;

var TableTreeColumn =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableTreeColumn, _React$PureComponent);

  function TableTreeColumn() {
    _classCallCheck(this, TableTreeColumn);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableTreeColumn).apply(this, arguments));
  }

  _createClass(TableTreeColumn, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          forColumnName = _this$props.for,
          showSelectionControls = _this$props.showSelectionControls,
          showSelectAll = _this$props.showSelectAll,
          Indent = _this$props.indentComponent,
          ExpandButton = _this$props.expandButtonComponent,
          Checkbox = _this$props.checkboxComponent,
          Content = _this$props.contentComponent,
          Cell = _this$props.cellComponent;
      return createElement(Plugin, {
        name: "TableTreeColumn",
        dependencies: [{
          name: 'DataTypeProvider',
          optional: true
        }, {
          name: 'TreeDataState'
        }, {
          name: 'SelectionState',
          optional: !showSelectionControls
        }, {
          name: 'IntegratedSelection',
          optional: !showSelectAll
        }, {
          name: 'Table'
        }, {
          name: 'TableHeaderRow',
          optional: true
        }]
      }, createElement(Getter, {
        name: "tableTreeColumnName",
        value: forColumnName
      }), createElement(Template, {
        name: "tableHeaderCellBefore",
        predicate: function predicate(_ref) {
          var column = _ref.column;
          return column.name === forColumnName;
        }
      }, createElement(ExpandButton, {
        visible: false
      }), showSelectionControls && showSelectAll && createElement(TemplateConnector, null, function (_ref2, _ref3) {
        var selectAllAvailable = _ref2.selectAllAvailable,
            allSelected$$1 = _ref2.allSelected,
            someSelected$$1 = _ref2.someSelected;
        var toggleSelectAll = _ref3.toggleSelectAll;
        return createElement(Checkbox, {
          disabled: !selectAllAvailable,
          checked: allSelected$$1,
          indeterminate: someSelected$$1,
          onChange: toggleSelectAll
        });
      })), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref4) {
          var tableRow = _ref4.tableRow,
              tableColumn = _ref4.tableColumn;
          return isTreeTableCell(tableRow, tableColumn, forColumnName);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref5, _ref6) {
          var getCollapsedRows = _ref5.getCollapsedRows,
              expandedRowIds = _ref5.expandedRowIds,
              selection = _ref5.selection,
              isTreeRowLeaf = _ref5.isTreeRowLeaf,
              getTreeRowLevel = _ref5.getTreeRowLevel,
              getCellValue = _ref5.getCellValue;
          var toggleRowExpanded$$1 = _ref6.toggleRowExpanded,
              toggleSelection$$1 = _ref6.toggleSelection;
          var _params$tableRow = params.tableRow,
              row = _params$tableRow.row,
              rowId = _params$tableRow.rowId;
          var columnName = params.tableColumn.column.name;
          var value = getCellValue(row, columnName);
          var collapsedRows = getCollapsedRows(row);
          return createElement(TemplatePlaceholder, {
            name: "valueFormatter",
            params: {
              row: row,
              column: params.tableColumn.column,
              value: value
            }
          }, function (content) {
            return createElement(Cell, _extends({}, params, {
              row: row,
              column: params.tableColumn.column,
              value: value
            }), createElement(Indent, {
              level: getTreeRowLevel(row)
            }), createElement(ExpandButton, {
              visible: collapsedRows ? !!collapsedRows.length : !isTreeRowLeaf(row),
              expanded: expandedRowIds.indexOf(rowId) > -1,
              onToggle: function onToggle() {
                return toggleRowExpanded$$1({
                  rowId: rowId
                });
              }
            }), showSelectionControls && createElement(Checkbox, {
              disabled: false,
              checked: selection.indexOf(rowId) > -1,
              indeterminate: false,
              onChange: function onChange() {
                return toggleSelection$$1({
                  rowIds: [rowId]
                });
              }
            }), createElement(Content, null, content || value));
          });
        });
      }));
    }
  }]);

  return TableTreeColumn;
}(PureComponent);
process.env.NODE_ENV !== "production" ? TableTreeColumn.propTypes = {
  for: string.isRequired,
  showSelectionControls: bool,
  showSelectAll: bool,
  cellComponent: func.isRequired,
  indentComponent: func.isRequired,
  expandButtonComponent: func.isRequired,
  checkboxComponent: func.isRequired,
  contentComponent: func.isRequired
} : void 0;
TableTreeColumn.defaultProps = {
  showSelectionControls: false,
  showSelectAll: false
};
TableTreeColumn.components = {
  cellComponent: 'Cell',
  contentComponent: 'Content',
  indentComponent: 'Indent',
  expandButtonComponent: 'ExpandButton',
  checkboxComponent: 'Checkbox'
};

var SearchState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(SearchState, _React$PureComponent);

  function SearchState(props) {
    var _this;

    _classCallCheck(this, SearchState);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchState).call(this, props));
    _this.state = {
      value: props.value || props.defaultValue
    };
    var stateHelper = createStateHelper(_assertThisInitialized(_assertThisInitialized(_this)), {
      value: function value() {
        var onValueChange = _this.props.onValueChange;
        return onValueChange;
      }
    });
    _this.changeValue = stateHelper.applyFieldReducer.bind(stateHelper, 'value', changeSearchValue);
    return _this;
  }

  _createClass(SearchState, [{
    key: "render",
    value: function render() {
      var value = this.state.value;

      var filterExpressionComputed = function filterExpressionComputed(_ref) {
        var filterExpression$$1 = _ref.filterExpression,
            columns = _ref.columns;
        return searchFilterExpression(value, columns, filterExpression$$1);
      };

      return createElement(Plugin, {
        name: "SearchState"
      }, createElement(Getter, {
        name: "filterExpression",
        computed: filterExpressionComputed
      }), createElement(Getter, {
        name: "searchValue",
        value: value
      }), createElement(Action, {
        name: "changeSearchValue",
        action: this.changeValue
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var _nextProps$value = nextProps.value,
          value = _nextProps$value === void 0 ? prevState.value : _nextProps$value;
      return {
        value: value
      };
    }
  }]);

  return SearchState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? SearchState.propTypes = {
  value: string,
  defaultValue: string,
  onValueChange: func
} : void 0;
SearchState.defaultProps = {
  value: undefined,
  defaultValue: '',
  onValueChange: undefined
};

var pluginDependencies$i = [{
  name: 'Toolbar'
}, {
  name: 'SearchState'
}];
var defaultMessages$6 = {
  searchPlaceholder: 'Search...'
};
var SearchPanel =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(SearchPanel, _React$PureComponent);

  function SearchPanel() {
    _classCallCheck(this, SearchPanel);

    return _possibleConstructorReturn(this, _getPrototypeOf(SearchPanel).apply(this, arguments));
  }

  _createClass(SearchPanel, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          Input = _this$props.inputComponent,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(_objectSpread({}, defaultMessages$6, messages));
      return createElement(Plugin, {
        name: "SearchPanel",
        dependencies: pluginDependencies$i
      }, createElement(Template, {
        name: "toolbarContent"
      }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_ref, _ref2) {
        var searchValue = _ref.searchValue;
        var changeSearchValue$$1 = _ref2.changeSearchValue;
        return createElement(Input, {
          value: searchValue,
          onValueChange: changeSearchValue$$1,
          getMessage: getMessage
        });
      })));
    }
  }]);

  return SearchPanel;
}(PureComponent);
process.env.NODE_ENV !== "production" ? SearchPanel.propTypes = {
  inputComponent: func.isRequired,
  messages: object
} : void 0;
SearchPanel.defaultProps = {
  messages: {}
};
SearchPanel.components = {
  inputComponent: 'Input'
};

var tableHeaderRowsComputed$2 = function tableHeaderRowsComputed(_ref) {
  var tableHeaderRows = _ref.tableHeaderRows;
  return tableHeaderRowsWithFixed(tableHeaderRows);
};

var tableHeaderColumnChainsComputed = function tableHeaderColumnChainsComputed(_ref2) {
  var tableColumns = _ref2.tableColumns,
      tableHeaderRows = _ref2.tableHeaderRows,
      tableHeaderColumnChains = _ref2.tableHeaderColumnChains;
  return tableHeaderColumnChainsWithFixed(tableHeaderColumnChains, tableHeaderRows, tableColumns);
};

var CellPlaceholder$2 = function CellPlaceholder(props) {
  return createElement(TemplatePlaceholder, {
    params: props
  });
};

var pluginDependencies$j = [{
  name: 'Table'
}, {
  name: 'TableBandHeader',
  optional: true
}, {
  name: 'TableColumnReordering',
  optional: true
}, {
  name: 'TableEditColumn',
  optional: true
}, {
  name: 'TableEditRow',
  optional: true
}, {
  name: 'TableFilterRow',
  optional: true
}, {
  name: 'TableHeaderRow',
  optional: true
}, {
  name: 'TableSelection',
  optional: true
}, {
  name: 'TableSummaryRow',
  optional: true
}, {
  name: 'TableTreeColumn',
  optional: true
}];
var TableFixedColumns =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableFixedColumns, _React$PureComponent);

  function TableFixedColumns(props) {
    var _this;

    _classCallCheck(this, TableFixedColumns);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TableFixedColumns).call(this, props));
    _this.state = {
      tableColumnDimensions: {}
    };
    return _this;
  }

  _createClass(TableFixedColumns, [{
    key: "handleListenerSizeChange",
    value: function handleListenerSizeChange(key, width) {
      this.setState(function (state) {
        return {
          tableColumnDimensions: _objectSpread({}, state.tableColumnDimensions, _defineProperty({}, key, width))
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          leftColumns = _this$props.leftColumns,
          rightColumns = _this$props.rightColumns,
          Cell = _this$props.cellComponent,
          ListenerRow = _this$props.listenerRowComponent,
          ListenerCell = _this$props.listenerCellComponent;

      var tableColumnsComputed = function tableColumnsComputed(_ref3) {
        var tableColumns = _ref3.tableColumns;
        return tableColumnsWithFixed(tableColumns, leftColumns, rightColumns);
      };

      return createElement(Plugin, {
        name: "TableFixedColumns",
        dependencies: pluginDependencies$j
      }, createElement(Getter, {
        name: "tableHeaderRows",
        computed: tableHeaderRowsComputed$2
      }), createElement(Getter, {
        name: "tableColumns",
        computed: tableColumnsComputed
      }), createElement(Getter, {
        name: "tableHeaderColumnChains",
        computed: tableHeaderColumnChainsComputed
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref4) {
          var tableColumn = _ref4.tableColumn;
          return !!tableColumn.fixed;
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref5) {
          var tableColumns = _ref5.tableColumns,
              tableHeaderColumnChains = _ref5.tableHeaderColumnChains;
          var tableColumnDimensions = _this2.state.tableColumnDimensions;
          var fixedColumnProps = calculateFixedColumnProps(params, {
            leftColumns: leftColumns,
            rightColumns: rightColumns
          }, tableColumns, tableColumnDimensions, tableHeaderColumnChains);
          return createElement(Cell, _extends({}, params, fixedColumnProps, {
            component: CellPlaceholder$2
          }));
        });
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref6) {
          var tableRow = _ref6.tableRow;
          return isFixedTableRow(tableRow);
        }
      }, function (params) {
        return createElement(ListenerRow, params);
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref7) {
          var tableRow = _ref7.tableRow;
          return isFixedTableRow(tableRow);
        }
      }, function (params) {
        return createElement(ListenerCell, _extends({}, params, {
          listen: !!params.tableColumn.fixed,
          onSizeChange: function onSizeChange(_ref8) {
            var width = _ref8.width;
            return _this2.handleListenerSizeChange(params.tableColumn.key, width);
          }
        }));
      }));
    }
  }]);

  return TableFixedColumns;
}(PureComponent);
process.env.NODE_ENV !== "production" ? TableFixedColumns.propTypes = {
  leftColumns: arrayOf(oneOfType([string, symbol])),
  rightColumns: arrayOf(oneOfType([string, symbol])),
  cellComponent: func.isRequired,
  listenerRowComponent: func.isRequired,
  listenerCellComponent: func.isRequired
} : void 0;
TableFixedColumns.defaultProps = {
  leftColumns: [],
  rightColumns: []
};
TableFixedColumns.components = {
  cellComponent: 'Cell',
  listenerRowComponent: 'ListenerRow',
  listenerCellComponent: 'ListenerCell'
};

var SummaryState =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(SummaryState, _React$PureComponent);

  function SummaryState() {
    _classCallCheck(this, SummaryState);

    return _possibleConstructorReturn(this, _getPrototypeOf(SummaryState).apply(this, arguments));
  }

  _createClass(SummaryState, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          totalItems = _this$props.totalItems,
          groupItems = _this$props.groupItems,
          treeItems = _this$props.treeItems;
      return createElement(Plugin, {
        name: "SummaryState"
      }, createElement(Getter, {
        name: "totalSummaryItems",
        value: totalItems
      }), createElement(Getter, {
        name: "groupSummaryItems",
        value: groupItems
      }), createElement(Getter, {
        name: "treeSummaryItems",
        value: treeItems
      }));
    }
  }]);

  return SummaryState;
}(PureComponent);
process.env.NODE_ENV !== "production" ? SummaryState.propTypes = {
  totalItems: array,
  groupItems: array,
  treeItems: array
} : void 0;
SummaryState.defaultProps = {
  totalItems: undefined,
  groupItems: undefined,
  treeItems: undefined
};

var pluginDependencies$k = [{
  name: 'SummaryState'
}];
var IntegratedSummary =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(IntegratedSummary, _React$PureComponent);

  function IntegratedSummary() {
    _classCallCheck(this, IntegratedSummary);

    return _possibleConstructorReturn(this, _getPrototypeOf(IntegratedSummary).apply(this, arguments));
  }

  _createClass(IntegratedSummary, [{
    key: "render",
    value: function render() {
      var calculator = this.props.calculator;

      var totalSummaryValuesComputed = function totalSummaryValuesComputed(_ref) {
        var rows = _ref.rows,
            totalSummaryItems = _ref.totalSummaryItems,
            getCellValue = _ref.getCellValue,
            getRowLevelKey = _ref.getRowLevelKey,
            isGroupRow = _ref.isGroupRow,
            getCollapsedRows = _ref.getCollapsedRows;
        return totalSummaryValues(rows, totalSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator);
      };

      var groupSummaryValuesComputed = function groupSummaryValuesComputed(_ref2) {
        var rows = _ref2.rows,
            groupSummaryItems = _ref2.groupSummaryItems,
            getCellValue = _ref2.getCellValue,
            getRowLevelKey = _ref2.getRowLevelKey,
            isGroupRow = _ref2.isGroupRow;
        return groupSummaryValues(rows, groupSummaryItems, getCellValue, getRowLevelKey, isGroupRow, calculator);
      };

      var treeSummaryValuesComputed = function treeSummaryValuesComputed(_ref3) {
        var rows = _ref3.rows,
            treeSummaryItems = _ref3.treeSummaryItems,
            getCellValue = _ref3.getCellValue,
            getRowLevelKey = _ref3.getRowLevelKey,
            isGroupRow = _ref3.isGroupRow,
            getRowId = _ref3.getRowId;
        return treeSummaryValues(rows, treeSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator);
      };

      return createElement(Plugin, {
        name: "IntegratedSummary",
        dependencies: pluginDependencies$k
      }, createElement(Getter, {
        name: "totalSummaryValues",
        computed: totalSummaryValuesComputed
      }), createElement(Getter, {
        name: "groupSummaryValues",
        computed: groupSummaryValuesComputed
      }), createElement(Getter, {
        name: "treeSummaryValues",
        computed: treeSummaryValuesComputed
      }));
    }
  }]);

  return IntegratedSummary;
}(PureComponent);
IntegratedSummary.defaultCalculator = defaultSummaryCalculator;
process.env.NODE_ENV !== "production" ? IntegratedSummary.propTypes = {
  calculator: func
} : void 0;
IntegratedSummary.defaultProps = {
  calculator: undefined
};

var pluginDependencies$l = [{
  name: 'SummaryState'
}];
var CustomSummary =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(CustomSummary, _React$PureComponent);

  function CustomSummary() {
    _classCallCheck(this, CustomSummary);

    return _possibleConstructorReturn(this, _getPrototypeOf(CustomSummary).apply(this, arguments));
  }

  _createClass(CustomSummary, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          totalValues = _this$props.totalValues,
          groupValues = _this$props.groupValues,
          treeValues = _this$props.treeValues;
      return createElement(Plugin, {
        name: "CustomSummary",
        dependencies: pluginDependencies$l
      }, createElement(Getter, {
        name: "totalSummaryValues",
        value: totalValues
      }), createElement(Getter, {
        name: "groupSummaryValues",
        value: groupValues
      }), createElement(Getter, {
        name: "treeSummaryValues",
        value: treeValues
      }));
    }
  }]);

  return CustomSummary;
}(PureComponent);
process.env.NODE_ENV !== "production" ? CustomSummary.propTypes = {
  totalValues: array,
  groupValues: object,
  treeValues: object
} : void 0;
CustomSummary.defaultProps = {
  totalValues: undefined,
  groupValues: undefined,
  treeValues: undefined
};

var dependencies$1 = [{
  name: 'DataTypeProvider',
  optional: true
}, {
  name: 'SummaryState'
}, {
  name: 'CustomSummary',
  optional: true
}, {
  name: 'IntegratedSummary',
  optional: true
}, {
  name: 'Table'
}, {
  name: 'TableTreeColumn',
  optional: true
}];
var defaultMessages$7 = {
  sum: 'Sum',
  min: 'Min',
  max: 'Max',
  avg: 'Avg',
  count: 'Count'
};

var tableBodyRowsComputed$2 = function tableBodyRowsComputed(_ref) {
  var tableBodyRows = _ref.tableBodyRows,
      getRowLevelKey = _ref.getRowLevelKey,
      isGroupRow = _ref.isGroupRow,
      getRowId = _ref.getRowId;
  return tableRowsWithSummaries(tableBodyRows, getRowLevelKey, isGroupRow, getRowId);
};

var tableFooterRowsComputed = function tableFooterRowsComputed(_ref2) {
  var tableFooterRows = _ref2.tableFooterRows;
  return tableRowsWithTotalSummaries(tableFooterRows);
};

var defaultTypelessSummaries = ['count'];
var TableSummaryRow =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableSummaryRow, _React$PureComponent);

  function TableSummaryRow() {
    _classCallCheck(this, TableSummaryRow);

    return _possibleConstructorReturn(this, _getPrototypeOf(TableSummaryRow).apply(this, arguments));
  }

  _createClass(TableSummaryRow, [{
    key: "renderContent",
    value: function renderContent(column, columnSummaries) {
      var _this$props = this.props,
          formatlessSummaryTypes = _this$props.formatlessSummaryTypes,
          Item = _this$props.itemComponent,
          messages = _this$props.messages;
      var getMessage = getMessagesFormatter(_objectSpread({}, defaultMessages$7, messages));

      var SummaryItem = function SummaryItem(_ref3) {
        var summary = _ref3.summary,
            children = _ref3.children;
        return createElement(Item, {
          getMessage: getMessage,
          type: summary.type,
          value: summary.value
        }, children || String(summary.value));
      };

      return createElement(Fragment, null, columnSummaries.map(function (summary) {
        if (summary.value === null || formatlessSummaryTypes.includes(summary.type) || defaultTypelessSummaries.includes(summary.type)) {
          return createElement(SummaryItem, {
            key: summary.type,
            summary: summary
          });
        }

        return createElement(TemplatePlaceholder, {
          key: summary.type,
          name: "valueFormatter",
          params: {
            column: column,
            value: summary.value
          }
        }, function (content) {
          return createElement(SummaryItem, {
            summary: summary
          }, content);
        });
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var _this$props2 = this.props,
          TotalRow = _this$props2.totalRowComponent,
          GroupRow = _this$props2.groupRowComponent,
          TreeRow = _this$props2.treeRowComponent,
          TotalCell = _this$props2.totalCellComponent,
          GroupCell = _this$props2.groupCellComponent,
          TreeCell = _this$props2.treeCellComponent,
          TreeColumnCell = _this$props2.treeColumnCellComponent,
          TreeColumnContent = _this$props2.treeColumnContentComponent,
          TreeColumnIndent = _this$props2.treeColumnIndentComponent;
      return createElement(Plugin, {
        name: "TableSummaryRow",
        dependencies: dependencies$1
      }, createElement(Getter, {
        name: "tableBodyRows",
        computed: tableBodyRowsComputed$2
      }), createElement(Getter, {
        name: "tableFooterRows",
        computed: tableFooterRowsComputed
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref4) {
          var tableRow = _ref4.tableRow,
              tableColumn = _ref4.tableColumn;
          return isTotalSummaryTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref5) {
          var totalSummaryItems = _ref5.totalSummaryItems,
              totalSummaryValues$$1 = _ref5.totalSummaryValues;
          var columnSummaries = getColumnSummaries(totalSummaryItems, params.tableColumn.column.name, totalSummaryValues$$1);
          return createElement(TotalCell, _extends({}, params, {
            column: params.tableColumn.column
          }), _this.renderContent(params.tableColumn.column, columnSummaries));
        });
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref6) {
          var tableRow = _ref6.tableRow,
              tableColumn = _ref6.tableColumn;
          return isGroupSummaryTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref7) {
          var groupSummaryItems = _ref7.groupSummaryItems,
              groupSummaryValues$$1 = _ref7.groupSummaryValues;
          var columnSummaries = getColumnSummaries(groupSummaryItems, params.tableColumn.column.name, groupSummaryValues$$1[params.tableRow.row.compoundKey]);
          return createElement(GroupCell, _extends({}, params, {
            column: params.tableColumn.column
          }), _this.renderContent(params.tableColumn.column, columnSummaries));
        });
      }), createElement(Template, {
        name: "tableCell",
        predicate: function predicate(_ref8) {
          var tableRow = _ref8.tableRow,
              tableColumn = _ref8.tableColumn;
          return isTreeSummaryTableCell(tableRow, tableColumn);
        }
      }, function (params) {
        return createElement(TemplateConnector, null, function (_ref9) {
          var treeSummaryItems = _ref9.treeSummaryItems,
              treeSummaryValues$$1 = _ref9.treeSummaryValues,
              tableTreeColumnName = _ref9.tableTreeColumnName,
              getRowId = _ref9.getRowId,
              getTreeRowLevel = _ref9.getTreeRowLevel;
          var columnSummaries = getColumnSummaries(treeSummaryItems, params.tableColumn.column.name, treeSummaryValues$$1[getRowId(params.tableRow.row)]);

          if (tableTreeColumnName === params.tableColumn.column.name) {
            return createElement(TreeColumnCell, _extends({}, params, {
              column: params.tableColumn.column
            }), createElement(TreeColumnIndent, {
              level: getTreeRowLevel(params.tableRow.row)
            }), createElement(TreeColumnContent, null, _this.renderContent(params.tableColumn.column, columnSummaries)));
          }

          return createElement(TreeCell, _extends({}, params, {
            column: params.tableColumn.column
          }), _this.renderContent(params.tableColumn.column, columnSummaries));
        });
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref10) {
          var tableRow = _ref10.tableRow;
          return isTotalSummaryTableRow(tableRow);
        }
      }, function (params) {
        return createElement(TotalRow, params);
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref11) {
          var tableRow = _ref11.tableRow;
          return isGroupSummaryTableRow(tableRow);
        }
      }, function (params) {
        return createElement(GroupRow, params);
      }), createElement(Template, {
        name: "tableRow",
        predicate: function predicate(_ref12) {
          var tableRow = _ref12.tableRow;
          return isTreeSummaryTableRow(tableRow);
        }
      }, function (params) {
        return createElement(TreeRow, params);
      }));
    }
  }]);

  return TableSummaryRow;
}(PureComponent);
TableSummaryRow.TREE_ROW_TYPE = TABLE_TREE_SUMMARY_TYPE;
TableSummaryRow.GROUP_ROW_TYPE = TABLE_GROUP_SUMMARY_TYPE;
TableSummaryRow.TOTAL_ROW_TYPE = TABLE_TOTAL_SUMMARY_TYPE;
process.env.NODE_ENV !== "production" ? TableSummaryRow.propTypes = {
  formatlessSummaryTypes: array,
  totalRowComponent: func.isRequired,
  groupRowComponent: func.isRequired,
  treeRowComponent: func.isRequired,
  totalCellComponent: func.isRequired,
  groupCellComponent: func.isRequired,
  treeCellComponent: func.isRequired,
  treeColumnCellComponent: func.isRequired,
  treeColumnContentComponent: func.isRequired,
  treeColumnIndentComponent: func.isRequired,
  itemComponent: func.isRequired,
  messages: shape({
    sum: string,
    min: string,
    max: string,
    avg: string,
    count: string
  })
} : void 0;
TableSummaryRow.defaultProps = {
  formatlessSummaryTypes: [],
  messages: {}
};
TableSummaryRow.components = {
  totalRowComponent: 'TotalRow',
  groupRowComponent: 'GroupRow',
  treeRowComponent: 'TreeRow',
  totalCellComponent: 'TotalCell',
  groupCellComponent: 'GroupCell',
  treeCellComponent: 'TreeCell',
  treeColumnCellComponent: 'TableTreeCell',
  treeColumnContentComponent: 'TableTreeContent',
  treeColumnIndentComponent: 'TableTreeIndent',
  itemComponent: 'Item'
};

var TableLayout =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TableLayout, _React$PureComponent);

  function TableLayout(props) {
    var _this;

    _classCallCheck(this, TableLayout);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TableLayout).call(this, props));
    _this.state = {
      animationState: new Map()
    };
    _this.animations = new Map();
    _this.savedScrolldWidth = {};
    _this.tableRef = createRef();
    return _this;
  }

  _createClass(TableLayout, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var columns = this.props.columns;
      var prevColumns = prevProps.columns;
      var tableWidth = this.getTableWidth(prevColumns, columns);
      this.animations = getAnimations(prevColumns, columns, tableWidth, this.animations);
      cancelAnimationFrame(this.raf);
      this.raf = requestAnimationFrame(this.processAnimationFrame.bind(this));
    }
  }, {
    key: "getTableWidth",
    value: function getTableWidth(prevColumns, columns) {
      var _this$tableRef$curren = this.tableRef.current,
          offsetWidth = _this$tableRef$curren.offsetWidth,
          scrollWidth = _this$tableRef$curren.scrollWidth;
      var animationState = this.state.animationState;
      var widthChanged = this.savedOffsetWidth !== offsetWidth || !this.savedScrolldWidth[columns.length];
      var columnCountChanged = columns.length !== prevColumns.length;

      if (columnCountChanged || widthChanged && !animationState.size) {
        this.savedScrolldWidth = {};
        this.savedScrolldWidth[columns.length] = scrollWidth;
        this.savedOffsetWidth = offsetWidth;
      }

      return this.savedScrolldWidth[columns.length];
    }
  }, {
    key: "getColumns",
    value: function getColumns() {
      var columns = this.props.columns;
      var animationState = this.state.animationState;
      var result = columns;
      var isFixedWidth = columns.filter(function (column) {
        return column.width === undefined;
      }).length === 0;

      if (isFixedWidth) {
        result = result.slice();
        result.push({
          key: TABLE_FLEX_TYPE.toString(),
          type: TABLE_FLEX_TYPE
        });
      }

      if (animationState.size) {
        result = result.map(function (column) {
          return animationState.has(column.key) ? _objectSpread({}, column, {
            animationState: animationState.get(column.key)
          }) : column;
        });
      }

      return result;
    }
  }, {
    key: "processAnimationFrame",
    value: function processAnimationFrame() {
      var animationComponentState = this.state.animationState;
      this.animations = filterActiveAnimations(this.animations);

      if (!this.animations.size) {
        if (animationComponentState.size) {
          this.setState({
            animationState: new Map()
          });
        }

        return;
      }

      var animationState = evalAnimations(this.animations);
      this.setState({
        animationState: animationState
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          Layout = _this$props.layoutComponent,
          minColumnWidth = _this$props.minColumnWidth,
          restProps = _objectWithoutProperties(_this$props, ["layoutComponent", "minColumnWidth"]);

      var columns = this.getColumns();
      var minWidth = columns.map(function (column) {
        return column.width || (column.type === TABLE_FLEX_TYPE ? 0 : minColumnWidth);
      }).reduce(function (acc, width) {
        return acc + width;
      }, 0);
      return createElement(Layout, _extends({}, restProps, {
        tableRef: this.tableRef,
        columns: columns,
        minWidth: minWidth,
        minColumnWidth: minColumnWidth
      }));
    }
  }]);

  return TableLayout;
}(PureComponent);
process.env.NODE_ENV !== "production" ? TableLayout.propTypes = {
  columns: array.isRequired,
  minColumnWidth: number.isRequired,
  layoutComponent: func.isRequired
} : void 0;

var ColumnGroup =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(ColumnGroup, _React$PureComponent);

  function ColumnGroup() {
    _classCallCheck(this, ColumnGroup);

    return _possibleConstructorReturn(this, _getPrototypeOf(ColumnGroup).apply(this, arguments));
  }

  _createClass(ColumnGroup, [{
    key: "render",
    value: function render() {
      var columns = this.props.columns;
      return createElement("colgroup", null, columns.map(function (column) {
        return createElement("col", {
          key: column.key,
          style: column.width !== undefined ? {
            width: "".concat(column.width, "px")
          } : null
        });
      }));
    }
  }]);

  return ColumnGroup;
}(PureComponent);
process.env.NODE_ENV !== "production" ? ColumnGroup.propTypes = {
  columns: array.isRequired
} : void 0;

var AUTO_HEIGHT = 'auto';
var VirtualTableLayout =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(VirtualTableLayout, _React$PureComponent);

  function VirtualTableLayout(props) {
    var _this;

    _classCallCheck(this, VirtualTableLayout);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(VirtualTableLayout).call(this, props));
    _this.state = {
      rowHeights: new Map(),
      viewportTop: 0,
      viewportLeft: 0,
      width: 800,
      height: 600
    };
    _this.state.headerHeight = props.headerRows.reduce(function (acc, row) {
      return acc + _this.getRowHeight(row);
    }, 0);
    _this.state.bodyHeight = 0;
    _this.state.footerHeight = props.footerRows.reduce(function (acc, row) {
      return acc + _this.getRowHeight(row);
    }, 0);
    _this.rowRefs = new Map();
    _this.blockRefs = new Map();
    _this.registerRowRef = _this.registerRowRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.getRowHeight = _this.getRowHeight.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.updateViewport = _this.updateViewport.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleContainerSizeChange = _this.handleContainerSizeChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(VirtualTableLayout, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.isEdgeBrowser = isEdgeBrowser();
      this.storeRowHeights();
      this.storeBloksHeights();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.storeRowHeights();
      this.storeBloksHeights();
    }
  }, {
    key: "getRowHeight",
    value: function getRowHeight(row) {
      var rowHeights = this.state.rowHeights;
      var estimatedRowHeight = this.props.estimatedRowHeight;
      var storedHeight = rowHeights.get(row.key);
      if (storedHeight !== undefined) return storedHeight;
      if (row.height) return row.height;
      return estimatedRowHeight;
    }
  }, {
    key: "storeRowHeights",
    value: function storeRowHeights() {
      var _this2 = this;

      var rowsWithChangedHeights = Array.from(this.rowRefs.entries()) // eslint-disable-next-line react/no-find-dom-node
      .map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            row = _ref2[0],
            ref = _ref2[1];

        return [row, findDOMNode(ref)];
      }).filter(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            node$$1 = _ref4[1];

        return !!node$$1;
      }).map(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
            row = _ref6[0],
            node$$1 = _ref6[1];

        return [row, node$$1.getBoundingClientRect().height];
      }).filter(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 1),
            row = _ref8[0];

        return row.type !== TABLE_STUB_TYPE;
      }).filter(function (_ref9) {
        var _ref10 = _slicedToArray(_ref9, 2),
            row = _ref10[0],
            height = _ref10[1];

        return height !== _this2.getRowHeight(row);
      });

      if (rowsWithChangedHeights.length) {
        var rowHeights = this.state.rowHeights;
        rowsWithChangedHeights.forEach(function (_ref11) {
          var _ref12 = _slicedToArray(_ref11, 2),
              row = _ref12[0],
              height = _ref12[1];

          return rowHeights.set(row.key, height);
        });
        this.setState({
          rowHeights: rowHeights
        });
      }
    }
  }, {
    key: "storeBloksHeights",
    value: function storeBloksHeights() {
      var headerHeight = this.blockRefs.get('header') // eslint-disable-next-line react/no-find-dom-node
      ? findDOMNode(this.blockRefs.get('header')).getBoundingClientRect().height : 0;
      var bodyHeight = this.blockRefs.get('body') // eslint-disable-next-line react/no-find-dom-node
      ? findDOMNode(this.blockRefs.get('body')).getBoundingClientRect().height : 0;
      var footerHeight = this.blockRefs.get('footer') // eslint-disable-next-line react/no-find-dom-node
      ? findDOMNode(this.blockRefs.get('footer')).getBoundingClientRect().height : 0;
      var _this$state = this.state,
          prevHeaderHeight = _this$state.headerHeight,
          prevBodyHeight = _this$state.bodyHeight,
          prevFooterHeight = _this$state.footerHeight;

      if (prevHeaderHeight !== headerHeight || prevBodyHeight !== bodyHeight || prevFooterHeight !== footerHeight) {
        this.setState({
          headerHeight: headerHeight,
          bodyHeight: bodyHeight,
          footerHeight: footerHeight
        });
      }
    }
  }, {
    key: "registerRowRef",
    value: function registerRowRef(row, ref) {
      if (ref === null) {
        this.rowRefs.delete(row);
      } else {
        this.rowRefs.set(row, ref);
      }
    }
  }, {
    key: "registerBlockRef",
    value: function registerBlockRef(name, ref) {
      if (ref === null) {
        this.blockRefs.delete(name);
      } else {
        this.blockRefs.set(name, ref);
      }
    }
  }, {
    key: "shouldSkipScrollEvent",
    value: function shouldSkipScrollEvent(e) {
      var node$$1 = e.target; // NOTE: prevent nested scroll to update viewport

      if (node$$1 !== e.currentTarget) {
        return true;
      } // NOTE: prevent iOS to flicker in bounces and correct rendering on high dpi screens


      var correction = this.isEdgeBrowser ? 1 : 0;
      var nodeHorizontalOffset = parseInt(node$$1.scrollLeft + node$$1.clientWidth, 10) - correction;
      var nodeVerticalOffset = parseInt(node$$1.scrollTop + node$$1.clientHeight, 10) - correction;

      if (node$$1.scrollTop < 0 || node$$1.scrollLeft < 0 || nodeHorizontalOffset > Math.max(node$$1.scrollWidth, node$$1.clientWidth) || nodeVerticalOffset > Math.max(node$$1.scrollHeight, node$$1.clientHeight)) {
        return true;
      }

      return false;
    }
  }, {
    key: "updateViewport",
    value: function updateViewport(e) {
      var node$$1 = e.target;

      if (this.shouldSkipScrollEvent(e)) {
        return;
      }

      this.setState({
        viewportTop: node$$1.scrollTop,
        viewportLeft: node$$1.scrollLeft
      });
    }
  }, {
    key: "handleContainerSizeChange",
    value: function handleContainerSizeChange(_ref13) {
      var width = _ref13.width,
          height = _ref13.height;
      this.setState({
        width: width,
        height: height
      });
    }
  }, {
    key: "renderRowsBlock",
    value: function renderRowsBlock(name, collapsedGrid, Table, Body, blockRef, marginBottom) {
      var _this3 = this;

      var _this$props = this.props,
          minWidth = _this$props.minWidth,
          Row = _this$props.rowComponent,
          Cell = _this$props.cellComponent;
      var tableRef = blockRef || createRef();
      return createElement(RefHolder, {
        ref: function ref(_ref15) {
          return _this3.registerBlockRef(name, _ref15);
        }
      }, createElement(Table, {
        tableRef: tableRef,
        style: _objectSpread({
          minWidth: "".concat(minWidth, "px")
        }, marginBottom ? {
          marginBottom: "".concat(marginBottom, "px")
        } : null)
      }, createElement(ColumnGroup, {
        columns: collapsedGrid.columns
      }), createElement(Body, null, collapsedGrid.rows.map(function (visibleRow) {
        var row = visibleRow.row,
            _visibleRow$cells = visibleRow.cells,
            cells = _visibleRow$cells === void 0 ? [] : _visibleRow$cells;
        return createElement(RefHolder, {
          key: row.key,
          ref: function ref(_ref14) {
            return _this3.registerRowRef(row, _ref14);
          }
        }, createElement(Row, {
          tableRow: row,
          style: row.height !== undefined ? {
            height: "".concat(row.height, "px")
          } : undefined
        }, cells.map(function (cell) {
          var column = cell.column;
          return createElement(Cell, {
            key: column.key,
            tableRow: row,
            tableColumn: column,
            style: column.animationState,
            colSpan: cell.colSpan
          });
        })));
      }))));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          headerRows = _this$props2.headerRows,
          bodyRows = _this$props2.bodyRows,
          footerRows = _this$props2.footerRows,
          columns = _this$props2.columns,
          minColumnWidth = _this$props2.minColumnWidth,
          propHeight = _this$props2.height,
          Container = _this$props2.containerComponent,
          HeadTable = _this$props2.headTableComponent,
          FootTable = _this$props2.footerTableComponent,
          Table = _this$props2.tableComponent,
          Head = _this$props2.headComponent,
          Body = _this$props2.bodyComponent,
          Footer = _this$props2.footerComponent,
          getCellColSpan = _this$props2.getCellColSpan,
          tableRef = _this$props2.tableRef;
      var _this$state2 = this.state,
          viewportLeft = _this$state2.viewportLeft,
          viewportTop = _this$state2.viewportTop,
          headerHeight = _this$state2.headerHeight,
          bodyHeight = _this$state2.bodyHeight,
          footerHeight = _this$state2.footerHeight,
          width = _this$state2.width,
          height = _this$state2.height;

      var getColumnWidth = function getColumnWidth(column) {
        return column.type === TABLE_FLEX_TYPE ? null : column.width || minColumnWidth;
      };

      var getColSpan = function getColSpan(tableRow, tableColumn) {
        return getCellColSpan({
          tableRow: tableRow,
          tableColumn: tableColumn,
          tableColumns: columns
        });
      };

      var collapsedHeaderGrid = getCollapsedGrid({
        rows: headerRows,
        columns: columns,
        top: 0,
        left: viewportLeft,
        width: width,
        height: headerHeight,
        getColumnWidth: getColumnWidth,
        getRowHeight: this.getRowHeight,
        getColSpan: getColSpan
      });
      var collapsedBodyGrid = getCollapsedGrid({
        rows: bodyRows,
        columns: columns,
        top: viewportTop,
        left: viewportLeft,
        width: width,
        height: height - headerHeight - footerHeight,
        getColumnWidth: getColumnWidth,
        getRowHeight: this.getRowHeight,
        getColSpan: getColSpan
      });
      var collapsedFooterGrid = getCollapsedGrid({
        rows: footerRows,
        columns: columns,
        top: 0,
        left: viewportLeft,
        width: width,
        height: footerHeight,
        getColumnWidth: getColumnWidth,
        getRowHeight: this.getRowHeight,
        getColSpan: getColSpan
      });
      return createElement(Sizer, {
        onSizeChange: this.handleContainerSizeChange,
        containerComponent: Container,
        style: _objectSpread({}, propHeight === AUTO_HEIGHT ? null : {
          height: "".concat(propHeight, "px")
        }),
        onScroll: this.updateViewport
      }, !!headerRows.length && this.renderRowsBlock('header', collapsedHeaderGrid, HeadTable, Head), this.renderRowsBlock('body', collapsedBodyGrid, Table, Body, tableRef, Math.max(0, height - headerHeight - bodyHeight - footerHeight)), !!footerRows.length && this.renderRowsBlock('footer', collapsedFooterGrid, FootTable, Footer));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var prevRowHeight = prevState.rowHeights;
      var rowHeights = [].concat(_toConsumableArray(nextProps.headerRows), _toConsumableArray(nextProps.bodyRows), _toConsumableArray(nextProps.footerRows)).reduce(function (acc, row) {
        var rowHeight = prevRowHeight.get(row.key);

        if (rowHeight !== undefined) {
          acc.set(row.key, rowHeight);
        }

        return acc;
      }, new Map());
      return {
        rowHeights: rowHeights
      };
    }
  }]);

  return VirtualTableLayout;
}(PureComponent);
process.env.NODE_ENV !== "production" ? VirtualTableLayout.propTypes = {
  minWidth: number.isRequired,
  minColumnWidth: number.isRequired,
  height: oneOfType([number, oneOf(['auto'])]).isRequired,
  headerRows: array,
  bodyRows: array.isRequired,
  footerRows: array,
  columns: array.isRequired,
  cellComponent: func.isRequired,
  rowComponent: func.isRequired,
  bodyComponent: func.isRequired,
  headComponent: func,
  footerComponent: func,
  tableComponent: func.isRequired,
  headTableComponent: func,
  footerTableComponent: func,
  containerComponent: func.isRequired,
  estimatedRowHeight: number.isRequired,
  getCellColSpan: func.isRequired,
  tableRef: RefType.isRequired
} : void 0;
VirtualTableLayout.defaultProps = {
  headerRows: [],
  footerRows: [],
  headComponent: function headComponent() {
    return null;
  },
  headTableComponent: function headTableComponent() {
    return null;
  },
  footerComponent: function footerComponent() {
    return null;
  },
  footerTableComponent: function footerTableComponent() {
    return null;
  }
};

var getColumnStyle = function getColumnStyle(_ref) {
  var column = _ref.column;
  return column.animationState;
};

var getRowStyle = function getRowStyle(_ref2) {
  var row = _ref2.row;
  return row.height !== undefined ? {
    height: "".concat(row.height, "px")
  } : undefined;
};

var RowLayout =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(RowLayout, _React$PureComponent);

  function RowLayout() {
    _classCallCheck(this, RowLayout);

    return _possibleConstructorReturn(this, _getPrototypeOf(RowLayout).apply(this, arguments));
  }

  _createClass(RowLayout, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          row = _this$props.row,
          columns = _this$props.columns,
          Row = _this$props.rowComponent,
          Cell = _this$props.cellComponent,
          getCellColSpan = _this$props.getCellColSpan;

      var getColSpan = function getColSpan(tableRow, tableColumn) {
        return getCellColSpan({
          tableRow: tableRow,
          tableColumn: tableColumn,
          tableColumns: columns
        });
      };

      return createElement(Row, {
        tableRow: row,
        style: getRowStyle({
          row: row
        })
      }, columns.map(function (column) {
        return createElement(Cell, {
          key: column.key,
          tableRow: row,
          tableColumn: column,
          style: getColumnStyle({
            column: column
          }),
          colSpan: getColSpan(row, column)
        });
      }));
    }
  }]);

  return RowLayout;
}(PureComponent);
process.env.NODE_ENV !== "production" ? RowLayout.propTypes = {
  row: any.isRequired,
  columns: array.isRequired,
  rowComponent: func.isRequired,
  cellComponent: func.isRequired,
  getCellColSpan: func.isRequired
} : void 0;

var RowsBlockLayout =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(RowsBlockLayout, _React$PureComponent);

  function RowsBlockLayout() {
    _classCallCheck(this, RowsBlockLayout);

    return _possibleConstructorReturn(this, _getPrototypeOf(RowsBlockLayout).apply(this, arguments));
  }

  _createClass(RowsBlockLayout, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          rows = _this$props.rows,
          columns = _this$props.columns,
          Block = _this$props.blockComponent,
          rowComponent = _this$props.rowComponent,
          cellComponent = _this$props.cellComponent,
          getCellColSpan = _this$props.getCellColSpan;
      return createElement(Block, null, rows.map(function (row) {
        return createElement(RowLayout, {
          key: row.key,
          row: row,
          columns: columns,
          rowComponent: rowComponent,
          cellComponent: cellComponent,
          getCellColSpan: getCellColSpan
        });
      }));
    }
  }]);

  return RowsBlockLayout;
}(PureComponent);
process.env.NODE_ENV !== "production" ? RowsBlockLayout.propTypes = {
  rows: array.isRequired,
  columns: array.isRequired,
  blockComponent: func.isRequired,
  rowComponent: func.isRequired,
  cellComponent: func.isRequired,
  getCellColSpan: func.isRequired
} : void 0;

var StaticTableLayout =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(StaticTableLayout, _React$PureComponent);

  function StaticTableLayout() {
    _classCallCheck(this, StaticTableLayout);

    return _possibleConstructorReturn(this, _getPrototypeOf(StaticTableLayout).apply(this, arguments));
  }

  _createClass(StaticTableLayout, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          headerRows = _this$props.headerRows,
          bodyRows = _this$props.bodyRows,
          footerRows = _this$props.footerRows,
          columns = _this$props.columns,
          minWidth = _this$props.minWidth,
          Container = _this$props.containerComponent,
          Table = _this$props.tableComponent,
          headComponent = _this$props.headComponent,
          bodyComponent = _this$props.bodyComponent,
          footerComponent = _this$props.footerComponent,
          rowComponent = _this$props.rowComponent,
          cellComponent = _this$props.cellComponent,
          getCellColSpan = _this$props.getCellColSpan,
          tableRef = _this$props.tableRef;
      return createElement(Container, null, createElement(Table, {
        tableRef: tableRef,
        style: {
          minWidth: "".concat(minWidth, "px")
        }
      }, createElement(ColumnGroup, {
        columns: columns
      }), !!headerRows.length && createElement(RowsBlockLayout, {
        rows: headerRows,
        columns: columns,
        blockComponent: headComponent,
        rowComponent: rowComponent,
        cellComponent: cellComponent,
        getCellColSpan: getCellColSpan
      }), createElement(RowsBlockLayout, {
        rows: bodyRows,
        columns: columns,
        blockComponent: bodyComponent,
        rowComponent: rowComponent,
        cellComponent: cellComponent,
        getCellColSpan: getCellColSpan
      }), !!footerRows.length && createElement(RowsBlockLayout, {
        rows: footerRows,
        columns: columns,
        blockComponent: footerComponent,
        rowComponent: rowComponent,
        cellComponent: cellComponent,
        getCellColSpan: getCellColSpan
      })));
    }
  }]);

  return StaticTableLayout;
}(PureComponent);
process.env.NODE_ENV !== "production" ? StaticTableLayout.propTypes = {
  headerRows: array,
  bodyRows: array.isRequired,
  footerRows: array,
  columns: array.isRequired,
  minWidth: number.isRequired,
  containerComponent: func.isRequired,
  tableComponent: func.isRequired,
  headComponent: func,
  bodyComponent: func.isRequired,
  footerComponent: func,
  rowComponent: func.isRequired,
  cellComponent: func.isRequired,
  getCellColSpan: func.isRequired,
  tableRef: RefType.isRequired
} : void 0;
StaticTableLayout.defaultProps = {
  headerRows: [],
  footerRows: [],
  headComponent: function headComponent() {
    return null;
  },
  footerComponent: function footerComponent() {
    return null;
  }
};

var makeVirtualTable = function makeVirtualTable(Table, _ref) {
  var VirtualLayout = _ref.VirtualLayout,
      FixedHeader = _ref.FixedHeader,
      FixedFooter = _ref.FixedFooter,
      defaultEstimatedRowHeight = _ref.defaultEstimatedRowHeight,
      defaultHeight = _ref.defaultHeight;

  var VirtualTable =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inherits(VirtualTable, _React$PureComponent);

    function VirtualTable(props) {
      var _this;

      _classCallCheck(this, VirtualTable);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(VirtualTable).call(this, props));
      _this.layoutRenderComponent = connectProps(VirtualLayout, function () {
        var _this$props = _this.props,
            height = _this$props.height,
            estimatedRowHeight = _this$props.estimatedRowHeight,
            headTableComponent = _this$props.headTableComponent,
            footerTableComponent = _this$props.footerTableComponent;
        return {
          height: height,
          estimatedRowHeight: estimatedRowHeight,
          headTableComponent: headTableComponent,
          footerTableComponent: footerTableComponent
        };
      });
      return _this;
    }

    _createClass(VirtualTable, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.layoutRenderComponent.update();
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            height = _this$props2.height,
            estimatedRowHeight = _this$props2.estimatedRowHeight,
            headTableComponent = _this$props2.headTableComponent,
            restProps = _objectWithoutProperties(_this$props2, ["height", "estimatedRowHeight", "headTableComponent"]);

        return createElement(Table, _extends({
          layoutComponent: this.layoutRenderComponent
        }, restProps));
      }
    }]);

    return VirtualTable;
  }(PureComponent);

  process.env.NODE_ENV !== "production" ? VirtualTable.propTypes = {
    estimatedRowHeight: number,
    height: oneOfType([number, oneOf(['auto'])]),
    headTableComponent: func,
    footerTableComponent: func
  } : void 0;
  VirtualTable.defaultProps = {
    estimatedRowHeight: defaultEstimatedRowHeight,
    height: defaultHeight,
    headTableComponent: FixedHeader,
    footerTableComponent: FixedFooter
  };
  Object.values(Table.components).forEach(function (name) {
    VirtualTable[name] = Table[name];
  });
  VirtualTable.FixedHeader = FixedHeader;
  VirtualTable.FixedFooter = FixedFooter;
  return VirtualTable;
};

export { Grid, ColumnChooser, FilteringState, IntegratedFiltering, EditingState, PagingState, IntegratedPaging, CustomPaging, GroupingState, IntegratedGrouping, CustomGrouping, SelectionState, IntegratedSelection, SortingState, IntegratedSorting, DragDropProvider$1 as DragDropProvider, TableColumnReordering, Table, TableSelection, RowDetailState, TableRowDetail, TableGroupRow, TableHeaderRow, TableBandHeader, TableFilterRow, TableEditRow, TableEditColumn, TableColumnResizing, PagingPanel, GroupingPanel, DataTypeProvider, TableColumnVisibility, Toolbar, TreeDataState, CustomTreeData, TableTreeColumn, SearchState, SearchPanel, TableFixedColumns, SummaryState, IntegratedSummary, CustomSummary, TableSummaryRow, TableLayout, VirtualTableLayout, StaticTableLayout, GroupPanelLayout, makeVirtualTable };
//# sourceMappingURL=dx-react-grid.es.js.map
